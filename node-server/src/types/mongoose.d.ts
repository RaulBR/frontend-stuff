export class Aggregate {
    constructor(pipeline: any, ...args: any[]);
    options: any;
    addCursorFlag(args: any): any;
    addFields(arg: any): any;
    allowDiskUse(value: any): any;
    append(...args: any[]): any;
    collation(collation: any): any;
    count(countName: any): any;
    cursor(options: any): any;
    exec(callback: any): any;
    explain(callback: any): any;
    facet(options: any): any;
    graphLookup(options: any): any;
    group(arg: any): any;
    hint(value: any): any;
    limit(arg: any): any;
    lookup(options: any): any;
    match(arg: any): any;
    model(model: any): any;
    near(arg: any): any;
    option(value: any): any;
    out(arg: any): any;
    pipeline(): any;
    project(arg: any, ...args: any[]): any;
    read(pref: any, tags: any): any;
    readConcern(level: any): any;
    redact(expression: any, thenExpr: any, elseExpr: any, ...args: any[]): any;
    replaceRoot(newRoot: any): any;
    sample(size: any): any;
    session(session: any): any;
    skip(arg: any): any;
    sort(arg: any, ...args: any[]): any;
    sortByCount(arg: any): any;
    then(resolve: any, reject: any): any;
    unwind(...args: any[]): any;
}
export class CastError {
    constructor(type: any, value: any, path: any, reason: any);
    name: any;
    stack: any;
    stringValue: any;
    kind: any;
    value: any;
    path: any;
    reason: any;
    setModel(model: any): void;
}
export class Collection {
    constructor(...args: any[]);
    collection: any;
    $format(arg: any): any;
    $print(name: any, i: any, args: any): void;
    $printToStream(name: any, i: any, args: any, stream: any): void;
    addQueue(name: any, args: any): any;
    aggregate(...args: any[]): any;
    bulkWrite(...args: any[]): any;
    count(...args: any[]): any;
    countDocuments(...args: any[]): any;
    createIndex(...args: any[]): any;
    createIndexes(...args: any[]): any;
    deleteMany(...args: any[]): any;
    deleteOne(...args: any[]): any;
    distinct(...args: any[]): any;
    doQueue(): any;
    drop(...args: any[]): any;
    dropAllIndexes(...args: any[]): any;
    dropIndex(...args: any[]): any;
    dropIndexes(...args: any[]): any;
    ensureIndex(...args: any[]): any;
    estimatedDocumentCount(...args: any[]): any;
    find(...args: any[]): any;
    findAndModify(...args: any[]): any;
    findAndRemove(...args: any[]): any;
    findOne(...args: any[]): any;
    findOneAndDelete(...args: any[]): any;
    findOneAndReplace(...args: any[]): any;
    findOneAndUpdate(...args: any[]): any;
    geoHaystackSearch(...args: any[]): any;
    getIndexes(...args: any[]): any;
    getLogger(...args: any[]): any;
    group(...args: any[]): any;
    indexExists(...args: any[]): any;
    indexInformation(...args: any[]): any;
    indexes(...args: any[]): any;
    initializeOrderedBulkOp(...args: any[]): any;
    initializeUnorderedBulkOp(...args: any[]): any;
    insert(...args: any[]): any;
    insertMany(...args: any[]): any;
    insertOne(...args: any[]): any;
    isCapped(...args: any[]): any;
    listIndexes(...args: any[]): any;
    mapReduce(...args: any[]): any;
    onClose(force: any): void;
    onOpen(): any;
    options(...args: any[]): any;
    parallelCollectionScan(...args: any[]): any;
    reIndex(...args: any[]): any;
    remove(...args: any[]): any;
    removeMany(...args: any[]): any;
    removeOne(...args: any[]): any;
    rename(...args: any[]): any;
    replaceOne(...args: any[]): any;
    save(...args: any[]): any;
    stats(...args: any[]): any;
    update(...args: any[]): any;
    updateMany(...args: any[]): any;
    updateOne(...args: any[]): any;
    watch(...args: any[]): any;
}
export class Connection {
    static STATES: {
        0: string;
        1: string;
        2: string;
        3: string;
        99: string;
        connected: number;
        connecting: number;
        disconnected: number;
        disconnecting: number;
        uninitialized: number;
    };
    constructor(...args: any[]);
    addListener(type: any, listener: any): any;
    authMechanismDoesNotRequirePassword(): any;
    close(force: any, callback: any): any;
    collection(name: any, options: any): any;
    createCollection(...args: any[]): any;
    deleteModel(name: any): any;
    doClose(force: any, fn: any): any;
    dropCollection(...args: any[]): any;
    dropDatabase(...args: any[]): any;
    emit(type: any, ...args: any[]): any;
    error(err: any, callback: any): any;
    eventNames(): any;
    getMaxListeners(): any;
    listenerCount(type: any): any;
    listeners(type: any): any;
    model(name: any, schema: any, collection: any): any;
    modelNames(): any;
    on(type: any, listener: any): any;
    onClose(force: any): void;
    onOpen(): void;
    once(type: any, listener: any): any;
    openUri(uri: any, options: any, callback: any): any;
    optionsProvideAuthenticationData(options: any): any;
    prependListener(type: any, listener: any): any;
    prependOnceListener(type: any, listener: any): any;
    removeAllListeners(type: any, ...args: any[]): any;
    removeListener(type: any, listener: any): any;
    setMaxListeners(n: any): any;
    shouldAuthenticate(): any;
    startSession(...args: any[]): any;
    useDb(name: any, options: any): any;
}
export class Decimal128 {
    static cast(caster: any, ...args: any[]): any;
    static checkRequired(fn: any, ...args: any[]): any;
    static schemaName: string;
    constructor(key: any, options: any);
    applyGetters(value: any, scope: any): any;
    applySetters(value: any, scope: any, init: any, priorVal: any, options: any): any;
    cast(value: any, doc: any, init: any): any;
    castForQuery($conditional: any, val: any, ...args: any[]): any;
    castForQueryWrapper(params: any): any;
    checkRequired(value: any, doc: any): any;
    doValidate(value: any, fn: any, scope: any): any;
    doValidateSync(value: any, scope: any): any;
    get(fn: any): any;
    getDefault(scope: any, init: any): any;
    index(options: any): any;
    ref(ref: any): any;
    required(required: any, message: any): any;
    select(val: any): any;
    set(fn: any): any;
    sparse(bool: any): any;
    text(bool: any): any;
    unique(bool: any): any;
    validate(obj: any, message: any, type: any, ...args: any[]): any;
}
export class Document {
    static ValidationError(instance: any): void;
    constructor(obj: any, fields: any, skipId: any, options: any);
    $__: any;
    isNew: any;
    errors: any;
    isNew: any;
    $__buildDoc(obj: any, fields: any, skipId: any, exclude: any, hasIncludedChildren: any): void;
    $__dirty(): any;
    $__fullPath(path: any): any;
    $__getAllSubdocs(): any;
    $__getArrayPathsToValidate(): any;
    $__handleReject(err: any): void;
    $__init(doc: any, opts: any): any;
    $__path(path: any): any;
    $__reset(): any;
    $__set(pathToMark: any, path: any, constructing: any, parts: any, schema: any, val: any, priorVal: any): void;
    $__setSchema(schema: any): void;
    $__shouldModify(pathToMark: any, path: any, constructing: any, parts: any, schema: any, val: any, priorVal: any): any;
    $__updateOne(doc: any, options: any, callback: any): any;
    $__validate(callback: any): any;
    $ignore(path: any): void;
    $isDefault(path: any): any;
    $isDeleted(val: any, ...args: any[]): any;
    $isValid(path: any): any;
    $markValid(path: any): void;
    $session(session: any, ...args: any[]): any;
    $set(path: any, val: any, type: any, options: any): any;
    $toObject(options: any, json: any): any;
    addListener(...args: any[]): any;
    depopulate(path: any, ...args: any[]): any;
    emit(...args: any[]): any;
    equals(doc: any): any;
    execPopulate(callback: any): any;
    get(path: any, type: any, options: any): any;
    getValue(path: any): any;
    init(doc: any, opts: any, fn: any): any;
    inspect(options: any): any;
    invalidate(path: any, err: any, val: any, kind: any): any;
    isDirectModified(path: any): any;
    isDirectSelected(path: any): any;
    isInit(path: any): any;
    isModified(paths: any, modifiedPaths: any): any;
    isSelected(path: any): any;
    listeners(...args: any[]): any;
    markModified(path: any, scope: any): void;
    modifiedPaths(options: any): any;
    on(...args: any[]): any;
    once(...args: any[]): any;
    populate(...args: any[]): any;
    populated(path: any, val: any, options: any): any;
    removeAllListeners(...args: any[]): any;
    removeListener(...args: any[]): any;
    replaceOne(...args: any[]): any;
    set(path: any, val: any, type: any, options: any): any;
    setMaxListeners(...args: any[]): any;
    setValue(path: any, val: any): any;
    toBSON(): any;
    toJSON(options: any): any;
    toObject(options: any): any;
    unmarkModified(path: any): void;
    update(...args: any[]): any;
    updateOne(doc: any, options: any, callback: any): any;
    validate(options: any, callback: any): any;
    validateSync(pathsToValidate: any): any;
}
export function DocumentProvider(): any;
export namespace DocumentProvider {
    function setBrowser(flag: any): void;
}
export class Error {
    static CastError(type: any, value: any, path: any, reason: any): void;
    static DivergentArrayError(paths: any): void;
    static DocumentNotFoundError(query: any): void;
    static Messages: {
        Date: {
            max: string;
            min: string;
        };
        DocumentNotFoundError: {};
        Number: {
            max: string;
            min: string;
        };
        String: {
            enum: string;
            match: string;
            maxlength: string;
            minlength: string;
        };
        general: {
            default: string;
            required: string;
        };
    };
    static MissingSchemaError(name: any): void;
    static OverwriteModelError(name: any): void;
    static ParallelSaveError(doc: any): void;
    static ValidationError(instance: any): void;
    static ValidatorError(properties: any): void;
    static VersionError(doc: any, currentVersion: any, modifiedPaths: any): void;
    static messages: {
        Date: {
            max: string;
            min: string;
        };
        DocumentNotFoundError: {};
        Number: {
            max: string;
            min: string;
        };
        String: {
            enum: string;
            match: string;
            maxlength: string;
            minlength: string;
        };
        general: {
            default: string;
            required: string;
        };
    };
    constructor(msg: any);
    stack: any;
    message: any;
    name: any;
}
export class Mixed {
    static get(getter: any): void;
    static schemaName: string;
    constructor(path: any, options: any);
    applyGetters(value: any, scope: any): any;
    applySetters(value: any, scope: any, init: any, priorVal: any, options: any): any;
    cast(val: any): any;
    castForQuery($cond: any, val: any, ...args: any[]): any;
    castForQueryWrapper(params: any): any;
    checkRequired(val: any): any;
    doValidate(value: any, fn: any, scope: any): any;
    doValidateSync(value: any, scope: any): any;
    get(fn: any): any;
    getDefault(scope: any, init: any): any;
    index(options: any): any;
    ref(ref: any): any;
    required(required: any, message: any): any;
    select(val: any): any;
    set(fn: any): any;
    sparse(bool: any): any;
    text(bool: any): any;
    unique(bool: any): any;
    validate(obj: any, message: any, type: any, ...args: any[]): any;
}
export class Model {
    static $__insertMany(arr: any, options: any, callback: any): void;
    static $where(...args: any[]): any;
    static $wrapCallback(callback: any): any;
    static addListener(type: any, listener: any): any;
    static aggregate(pipeline: any, callback: any, ...args: any[]): any;
    static bulkWrite(ops: any, options: any, callback: any): any;
    static compile(name: any, schema: any, collectionName: any, connection: any, base: any): any;
    static count(conditions: any, callback: any): any;
    static countDocuments(conditions: any, callback: any): any;
    static create(doc: any, options: any, callback: any, ...args: any[]): any;
    static createCollection(options: any, callback: any): any;
    static createIndexes(options: any, callback: any): any;
    static deleteMany(conditions: any, options: any, callback: any): any;
    static deleteOne(conditions: any, callback: any): any;
    static discriminator(name: any, schema: any, value: any): any;
    static distinct(field: any, conditions: any, callback: any): any;
    static domain: any;
    static emit(type: any, ...args: any[]): any;
    static ensureIndexes(options: any, callback: any): any;
    static estimatedDocumentCount(options: any, callback: any): any;
    static eventNames(): any;
    static find(conditions: any, projection: any, options: any, callback: any): any;
    static findById(id: any, projection: any, options: any, callback: any): any;
    static findByIdAndDelete(id: any, options: any, callback: any, ...args: any[]): any;
    static findByIdAndRemove(id: any, options: any, callback: any, ...args: any[]): any;
    static findByIdAndUpdate(id: any, update: any, options: any, callback: any, ...args: any[]): any;
    static findOne(conditions: any, projection: any, options: any, callback: any): any;
    static findOneAndDelete(conditions: any, options: any, callback: any, ...args: any[]): any;
    static findOneAndRemove(conditions: any, options: any, callback: any, ...args: any[]): any;
    static findOneAndReplace(conditions: any, options: any, callback: any, ...args: any[]): any;
    static findOneAndUpdate(conditions: any, update: any, options: any, callback: any, ...args: any[]): any;
    static geoSearch(conditions: any, options: any, callback: any): any;
    static getMaxListeners(): any;
    static hydrate(obj: any): any;
    static init(callback: any): any;
    static insertMany(arr: any, options: any, callback: any): any;
    static listIndexes(callback: any): any;
    static listenerCount(type: any): any;
    static listeners(type: any): any;
    static mapReduce(o: any, callback: any): any;
    static on(type: any, listener: any): any;
    static once(type: any, listener: any): any;
    static populate(docs: any, paths: any, callback: any): any;
    static prependListener(type: any, listener: any): any;
    static prependOnceListener(type: any, listener: any): any;
    static remove(conditions: any, callback: any): any;
    static removeAllListeners(type: any, ...args: any[]): any;
    static removeListener(type: any, listener: any): any;
    static replaceOne(conditions: any, doc: any, options: any, callback: any): any;
    static setMaxListeners(n: any): any;
    static startSession(...args: any[]): any;
    static syncIndexes(options: any, callback: any): any;
    static translateAliases(fields: any): any;
    static update(conditions: any, doc: any, options: any, callback: any): any;
    static updateMany(conditions: any, doc: any, options: any, callback: any): any;
    static updateOne(conditions: any, doc: any, options: any, callback: any): any;
    static watch(pipeline: any, options: any): any;
    static where(path: any, val: any, ...args: any[]): any;
    constructor(doc: any, fields: any, skipId: any);
    $__buildDoc(obj: any, fields: any, skipId: any, exclude: any, hasIncludedChildren: any): void;
    $__delta(): any;
    $__dirty(): any;
    $__fullPath(path: any): any;
    $__getAllSubdocs(): any;
    $__getArrayPathsToValidate(): any;
    $__handleReject(err: any): void;
    $__handleSave(options: any, callback: any): void;
    $__init(doc: any, opts: any): any;
    $__path(path: any): any;
    $__remove(options: any, cb: any): any;
    $__reset(): any;
    $__save(options: any, callback: any): void;
    $__set(pathToMark: any, path: any, constructing: any, parts: any, schema: any, val: any, priorVal: any): void;
    $__setSchema(schema: any): void;
    $__shouldModify(pathToMark: any, path: any, constructing: any, parts: any, schema: any, val: any, priorVal: any): any;
    $__updateOne(doc: any, options: any, callback: any): any;
    $__validate(callback: any): any;
    $__version(where: any, delta: any): void;
    $__where(where: any): any;
    $ignore(path: any): void;
    $isDefault(path: any): any;
    $isDeleted(val: any, ...args: any[]): any;
    $isValid(path: any): any;
    $markValid(path: any): void;
    $session(session: any, ...args: any[]): any;
    $set(path: any, val: any, type: any, options: any): any;
    $toObject(options: any, json: any): any;
    addListener(...args: any[]): any;
    depopulate(path: any, ...args: any[]): any;
    emit(...args: any[]): any;
    equals(doc: any): any;
    execPopulate(callback: any): any;
    get(path: any, type: any, options: any): any;
    getValue(path: any): any;
    increment(): any;
    init(doc: any, opts: any, fn: any): any;
    inspect(options: any): any;
    invalidate(path: any, err: any, val: any, kind: any): any;
    isDirectModified(path: any): any;
    isDirectSelected(path: any): any;
    isInit(path: any): any;
    isModified(paths: any, modifiedPaths: any): any;
    isSelected(path: any): any;
    listeners(...args: any[]): any;
    markModified(path: any, scope: any): void;
    model(name: any): any;
    modifiedPaths(options: any): any;
    on(...args: any[]): any;
    once(...args: any[]): any;
    populate(...args: any[]): any;
    populated(path: any, val: any, options: any): any;
    remove(options: any, fn: any): any;
    removeAllListeners(...args: any[]): any;
    removeListener(...args: any[]): any;
    replaceOne(...args: any[]): any;
    save(options: any, fn: any): any;
    set(path: any, val: any, type: any, options: any): any;
    setMaxListeners(...args: any[]): any;
    setValue(path: any, val: any): any;
    toBSON(): any;
    toJSON(options: any): any;
    toObject(options: any): any;
    unmarkModified(path: any): void;
    update(...args: any[]): any;
    updateOne(doc: any, options: any, callback: any): any;
    validate(options: any, callback: any): any;
    validateSync(pathsToValidate: any): any;
}
export class Mongoose {
    constructor(options: any);
    connections: any;
    models: any;
    modelSchemas: any;
    options: any;
    Schema: any;
    Aggregate(pipeline: any, ...args: any[]): void;
    CastError(type: any, value: any, path: any, reason: any): void;
    Collection(...args: any[]): void;
    Connection(...args: any[]): void;
    Decimal128(key: any, options: any): void;
    Document(obj: any, fields: any, skipId: any, options: any): void;
    DocumentProvider(): any;
    Error(msg: any): void;
    Mixed(path: any, options: any): void;
    Model(doc: any, fields: any, skipId: any): void;
    Number(key: any, options: any): void;
    ObjectId(key: any, options: any): void;
    Query(conditions: any, options: any, model: any, collection: any): void;
    Schema(obj: any, options: any): any;
    SchemaType(path: any, options: any, instance: any): void;
    VirtualType(options: any, name: any): void;
    connect(...args: any[]): any;
    createConnection(uri: any, options: any, callback: any, ...args: any[]): any;
    deleteModel(name: any): any;
    disconnect(callback: any): any;
    get(key: any, value: any, ...args: any[]): any;
    model(name: any, schema: any, collection: any, skipInit: any): any;
    modelNames(): any;
    mongo(url: any, options: any, callback: any, ...args: any[]): any;
    mquery(criteria: any, options: any): any;
    now(): any;
    plugin(fn: any, opts: any): any;
    pluralize(fn: any, ...args: any[]): any;
    set(key: any, value: any, ...args: any[]): any;
    startSession(...args: any[]): any;
}
export class Number {
    static cast(caster: any, ...args: any[]): any;
    static checkRequired(fn: any, ...args: any[]): any;
    static get(getter: any): void;
    static schemaName: string;
    constructor(key: any, options: any);
    applyGetters(value: any, scope: any): any;
    applySetters(value: any, scope: any, init: any, priorVal: any, options: any): any;
    cast(value: any, doc: any, init: any): any;
    castForQuery($conditional: any, val: any, ...args: any[]): any;
    castForQueryWrapper(params: any): any;
    checkRequired(value: any, doc: any): any;
    doValidate(value: any, fn: any, scope: any): any;
    doValidateSync(value: any, scope: any): any;
    get(fn: any): any;
    getDefault(scope: any, init: any): any;
    index(options: any): any;
    max(value: any, message: any): any;
    min(value: any, message: any): any;
    ref(ref: any): any;
    required(required: any, message: any): any;
    select(val: any): any;
    set(fn: any): any;
    sparse(bool: any): any;
    text(bool: any): any;
    unique(bool: any): any;
    validate(obj: any, message: any, type: any, ...args: any[]): any;
}
export class ObjectId {
    static cast(caster: any, ...args: any[]): any;
    static checkRequired(fn: any, ...args: any[]): any;
    static get(getter: any): void;
    static schemaName: string;
    constructor(key: any, options: any);
    applyGetters(value: any, scope: any): any;
    applySetters(value: any, scope: any, init: any, priorVal: any, options: any): any;
    auto(turnOn: any): any;
    cast(value: any, doc: any, init: any): any;
    castForQuery($conditional: any, val: any, ...args: any[]): any;
    castForQueryWrapper(params: any): any;
    checkRequired(value: any, doc: any): any;
    doValidate(value: any, fn: any, scope: any): any;
    doValidateSync(value: any, scope: any): any;
    get(fn: any): any;
    getDefault(scope: any, init: any): any;
    index(options: any): any;
    ref(ref: any): any;
    required(required: any, message: any): any;
    select(val: any): any;
    set(fn: any): any;
    sparse(bool: any): any;
    text(bool: any): any;
    unique(bool: any): any;
    validate(obj: any, message: any, type: any, ...args: any[]): any;
}
export const Promise: any;
export namespace PromiseProvider {
    function get(): any;
    function set(lib: any): void;
}
export class Query {
    static use$geoWithin: boolean;
    constructor(conditions: any, options: any, model: any, collection: any);
    mongooseCollection: any;
    model: any;
    schema: any;
    options: any;
    $useProjection: any;
    $where(js: any): any;
    all(...args: any[]): any;
    and(array: any): any;
    batchSize(v: any): any;
    box(ll: any, ur: any): any;
    cast(model: any, obj: any): any;
    center(...args: any[]): any;
    centerSphere(...args: any[]): void;
    circle(...args: any[]): any;
    collation(value: any): any;
    collection(coll: any): any;
    comment(v: any): any;
    count(filter: any, callback: any): any;
    countDocuments(conditions: any, callback: any): any;
    cursor(opts: any): any;
    deleteMany(filter: any, callback: any): any;
    deleteOne(filter: any, callback: any): any;
    distinct(field: any, conditions: any, callback: any): any;
    elemMatch(...args: any[]): any;
    eq(val: any): any;
    equals(val: any): any;
    error(err: any, ...args: any[]): any;
    estimatedDocumentCount(options: any, callback: any): any;
    exec(op: any, callback: any): any;
    exists(...args: any[]): any;
    explain(verbose: any, ...args: any[]): any;
    find(conditions: any, callback: any): any;
    findOne(conditions: any, projection: any, options: any, callback: any): any;
    findOneAndDelete(conditions: any, options: any, callback: any, ...args: any[]): any;
    findOneAndRemove(conditions: any, options: any, callback: any, ...args: any[]): any;
    findOneAndReplace(conditions: any, options: any, callback: any, ...args: any[]): any;
    findOneAndUpdate(criteria: any, doc: any, options: any, callback: any, ...args: any[]): any;
    geometry(...args: any[]): any;
    getOptions(): any;
    getPopulatedPaths(): any;
    getQuery(): any;
    getUpdate(): any;
    gt(...args: any[]): any;
    gte(...args: any[]): any;
    hint(...args: any[]): any;
    intersects(...args: any[]): any;
    j(val: any): any;
    lean(v: any, ...args: any[]): any;
    limit(v: any): any;
    lt(...args: any[]): any;
    lte(...args: any[]): any;
    map(fn: any): any;
    maxDistance(...args: any[]): any;
    maxScan(v: any): any;
    maxTime(ms: any): any;
    maxTimeMS(ms: any): any;
    maxscan(v: any): any;
    merge(source: any): any;
    minDistance(...args: any[]): any;
    mod(...args: any[]): any;
    mongooseOptions(v: any, ...args: any[]): any;
    ne(...args: any[]): any;
    near(...args: any[]): any;
    nearSphere(...args: any[]): any;
    nin(...args: any[]): any;
    nor(array: any): any;
    or(array: any): any;
    orFail(err: any): any;
    polygon(...args: any[]): any;
    populate(...args: any[]): any;
    r(level: any): any;
    read(pref: any, tags: any): any;
    readConcern(level: any): any;
    regex(...args: any[]): any;
    remove(filter: any, callback: any): any;
    replaceOne(conditions: any, doc: any, options: any, callback: any): any;
    select(...args: any[]): any;
    selected(): any;
    selectedExclusively(): any;
    selectedInclusively(): any;
    session(v: any): any;
    set(path: any, val: any): any;
    setOptions(options: any, overwrite: any): any;
    setQuery(val: any): void;
    setReadPreference(pref: any, ...args: any[]): any;
    setTraceFunction(traceFunction: any): any;
    setUpdate(val: any): void;
    size(...args: any[]): any;
    skip(v: any): any;
    slaveOk(v: any, ...args: any[]): any;
    slice(...args: any[]): any;
    snapshot(...args: any[]): any;
    sort(arg: any, ...args: any[]): any;
    stream(streamOptions: any): any;
    tailable(val: any, opts: any): any;
    then(resolve: any, reject: any): any;
    thunk(): any;
    toConstructor(): any;
    update(conditions: any, doc: any, options: any, callback: any): any;
    updateMany(conditions: any, doc: any, options: any, callback: any): any;
    updateOne(conditions: any, doc: any, options: any, callback: any): any;
    w(val: any): any;
    wTimeout(ms: any): any;
    where(...args: any[]): any;
    within(...args: any[]): any;
    writeConcern(concern: any): any;
    wtimeout(ms: any): any;
}
export namespace Query {
    namespace base {
        function $where(js: any): any;
        function all(...args: any[]): any;
        function and(array: any): any;
        function batchSize(v: any): any;
        function box(...args: any[]): any;
        function circle(...args: any[]): any;
        function collation(value: any): any;
        function collection(coll: any): any;
        function comment(v: any): any;
        class count {
            constructor(criteria: any, callback: any);
            op: any;
        }
        function cursor(criteria: any): any;
        class deleteMany {
            constructor(criteria: any, callback: any);
            op: any;
        }
        class deleteOne {
            constructor(criteria: any, callback: any);
            op: any;
        }
        class distinct {
            constructor(criteria: any, field: any, callback: any);
            op: any;
        }
        function elemMatch(...args: any[]): any;
        function eq(val: any): any;
        function equals(val: any): any;
        class exec {
            constructor(op: any, callback: any);
            op: any;
        }
        function exists(...args: any[]): any;
        class find {
            constructor(criteria: any, callback: any);
            op: any;
        }
        class findOne {
            constructor(criteria: any, callback: any);
            op: any;
        }
        class findOneAndDelete {
            constructor(conditions: any, options: any, callback: any);
            op: any;
        }
        class findOneAndRemove {
            constructor(conditions: any, options: any, callback: any);
            op: any;
        }
        class findOneAndUpdate {
            constructor(criteria: any, doc: any, options: any, callback: any, ...args: any[]);
            op: any;
        }
        function geometry(...args: any[]): any;
        function gt(...args: any[]): any;
        function gte(...args: any[]): any;
        function hint(...args: any[]): any;
        function intersects(...args: any[]): any;
        function j(val: any): any;
        function limit(v: any): any;
        function lt(...args: any[]): any;
        function lte(...args: any[]): any;
        function maxDistance(...args: any[]): any;
        function maxScan(v: any): any;
        function maxTime(ms: any): any;
        function maxTimeMS(ms: any): any;
        class merge {
            constructor(source: any);
            options: any;
        }
        function minDistance(...args: any[]): any;
        function mod(...args: any[]): any;
        function ne(...args: any[]): any;
        function near(...args: any[]): any;
        function nin(...args: any[]): any;
        function nor(array: any): any;
        function or(array: any): any;
        function polygon(...args: any[]): any;
        function r(level: any): any;
        function read(pref: any, ...args: any[]): any;
        function readConcern(level: any): any;
        function regex(...args: any[]): any;
        class remove {
            constructor(criteria: any, callback: any);
            op: any;
        }
        function replaceOne(criteria: any, doc: any, options: any, callback: any, ...args: any[]): any;
        function select(...args: any[]): any;
        function selected(): any;
        function selectedExclusively(): any;
        function selectedInclusively(): any;
        function setOptions(options: any): any;
        function setReadPreference(pref: any, ...args: any[]): any;
        function setTraceFunction(traceFunction: any): any;
        function size(...args: any[]): any;
        function skip(v: any): any;
        function slaveOk(v: any, ...args: any[]): any;
        function slice(...args: any[]): any;
        function snapshot(...args: any[]): any;
        function sort(arg: any, ...args: any[]): any;
        function stream(streamOptions: any): any;
        function tailable(...args: any[]): any;
        function then(resolve: any, reject: any): any;
        function thunk(): any;
        function toConstructor(): any;
        function update(criteria: any, doc: any, options: any, callback: any, ...args: any[]): any;
        function updateMany(criteria: any, doc: any, options: any, callback: any, ...args: any[]): any;
        function updateOne(criteria: any, doc: any, options: any, callback: any, ...args: any[]): any;
        function w(concern: any): any;
        function wTimeout(ms: any): any;
        class where {
            constructor(...args: any[]);
            op: any;
        }
        function within(...args: any[]): any;
        function writeConcern(concern: any): any;
        function wtimeout(ms: any): any;
    }
}
export const STATES: {
    0: string;
    1: string;
    2: string;
    3: string;
    99: string;
    connected: number;
    connecting: number;
    disconnected: number;
    disconnecting: number;
    uninitialized: number;
};
export class Schema {
    static indexTypes: any;
    static reserved: {
        collection: number;
        db: number;
        emit: number;
        errors: number;
        get: number;
        init: number;
        isModified: number;
        isNew: number;
        listeners: number;
        modelName: number;
        on: number;
        once: number;
        prototype: number;
        remove: number;
        removeListener: number;
        save: number;
        schema: number;
        toObject: number;
        validate: number;
    };
    constructor(obj: any, options: any);
    obj: any;
    paths: any;
    aliases: any;
    subpaths: any;
    virtuals: any;
    singleNestedPaths: any;
    nested: any;
    inherits: any;
    callQueue: any;
    methods: any;
    methodOptions: any;
    statics: any;
    tree: any;
    query: any;
    childSchemas: any;
    plugins: any;
    $id: any;
    s: any;
    options: any;
    add(obj: any, prefix: any): any;
    addListener(type: any, listener: any): any;
    clone(): any;
    defaultOptions(options: any): any;
    eachPath(fn: any): any;
    emit(type: any, ...args: any[]): any;
    eventNames(): any;
    get(key: any): any;
    getMaxListeners(): any;
    hasMixedParent(path: any): any;
    index(fields: any, options: any): any;
    indexedPaths(): any;
    indexes(): any;
    interpretAsType(path: any, obj: any, options: any): any;
    listenerCount(type: any): any;
    listeners(type: any): any;
    loadClass(model: any, virtualsOnly: any): any;
    method(name: any, fn: any, options: any): any;
    on(type: any, listener: any): any;
    once(type: any, listener: any): any;
    path(path: any, obj: any): any;
    pathType(path: any): any;
    plugin(fn: any, opts: any): any;
    post(name: any, ...args: any[]): any;
    pre(name: any, ...args: any[]): any;
    prependListener(type: any, listener: any): any;
    prependOnceListener(type: any, listener: any): any;
    queue(name: any, args: any): any;
    remove(path: any): any;
    removeAllListeners(type: any, ...args: any[]): any;
    removeListener(type: any, listener: any): any;
    requiredPaths(invalidate: any): any;
    set(key: any, value: any, _tags: any, ...args: any[]): any;
    setMaxListeners(n: any): any;
    setupTimestamp(timestamps: any): void;
    virtual(name: any, options: any): any;
    virtualpath(name: any): any;
}
export namespace Schema {
    class ObjectId {
        static cast(caster: any, ...args: any[]): any;
        static checkRequired(fn: any, ...args: any[]): any;
        static get(getter: any): void;
        static schemaName: string;
        constructor(key: any, options: any);
        applyGetters(value: any, scope: any): any;
        applySetters(value: any, scope: any, init: any, priorVal: any, options: any): any;
        auto(turnOn: any): any;
        cast(value: any, doc: any, init: any): any;
        castForQuery($conditional: any, val: any, ...args: any[]): any;
        castForQueryWrapper(params: any): any;
        checkRequired(value: any, doc: any): any;
        doValidate(value: any, fn: any, scope: any): any;
        doValidateSync(value: any, scope: any): any;
        get(fn: any): any;
        getDefault(scope: any, init: any): any;
        index(options: any): any;
        ref(ref: any): any;
        required(required: any, message: any): any;
        select(val: any): any;
        set(fn: any): any;
        sparse(bool: any): any;
        text(bool: any): any;
        unique(bool: any): any;
        validate(obj: any, message: any, type: any, ...args: any[]): any;
    }
    namespace Types {
        class Array {
            static schemaName: string;
            constructor(key: any, cast: any, options: any, schemaOptions: any);
            casterConstructor: any;
            caster: any;
            caster: any;
            $isMongooseArray: any;
            applyGetters(value: any, scope: any): any;
            applySetters(value: any, scope: any, init: any, priorVal: any, options: any): any;
            cast(value: any, doc: any, init: any): any;
            castForQuery($conditional: any, value: any, ...args: any[]): any;
            castForQueryWrapper(params: any): any;
            checkRequired(val: any): any;
            discriminator(name: any, schema: any): any;
            doValidate(value: any, fn: any, scope: any): any;
            doValidateSync(value: any, scope: any): any;
            get(fn: any): any;
            getDefault(scope: any, init: any): any;
            index(options: any): any;
            ref(ref: any): any;
            required(required: any, message: any): any;
            select(val: any): any;
            set(fn: any): any;
            sparse(bool: any): any;
            text(bool: any): any;
            unique(bool: any): any;
            validate(obj: any, message: any, type: any, ...args: any[]): any;
        }
        class Bool {
            static $conditionalHandlers: {
                $all: any;
                $eq: any;
                $exists: any;
                $in: any;
                $ne: any;
                $nin: any;
                $type: any;
            };
            static cast(caster: any, ...args: any[]): any;
            static checkRequired(fn: any, ...args: any[]): any;
            static convertToFalse: any;
            static convertToTrue: any;
            static schemaName: string;
            constructor(path: any, options: any);
            applyGetters(value: any, scope: any): any;
            applySetters(value: any, scope: any, init: any, priorVal: any, options: any): any;
            cast(value: any): any;
            castForQuery($conditional: any, val: any, ...args: any[]): any;
            castForQueryWrapper(params: any): any;
            checkRequired(value: any): any;
            doValidate(value: any, fn: any, scope: any): any;
            doValidateSync(value: any, scope: any): any;
            get(fn: any): any;
            getDefault(scope: any, init: any): any;
            index(options: any): any;
            ref(ref: any): any;
            required(required: any, message: any): any;
            select(val: any): any;
            set(fn: any): any;
            sparse(bool: any): any;
            text(bool: any): any;
            unique(bool: any): any;
            validate(obj: any, message: any, type: any, ...args: any[]): any;
        }
        class Boolean {
            static $conditionalHandlers: {
                $all: any;
                $eq: any;
                $exists: any;
                $in: any;
                $ne: any;
                $nin: any;
                $type: any;
            };
            static cast(caster: any, ...args: any[]): any;
            static checkRequired(fn: any, ...args: any[]): any;
            static convertToFalse: any;
            static convertToTrue: any;
            static schemaName: string;
            constructor(path: any, options: any);
            applyGetters(value: any, scope: any): any;
            applySetters(value: any, scope: any, init: any, priorVal: any, options: any): any;
            cast(value: any): any;
            castForQuery($conditional: any, val: any, ...args: any[]): any;
            castForQueryWrapper(params: any): any;
            checkRequired(value: any): any;
            doValidate(value: any, fn: any, scope: any): any;
            doValidateSync(value: any, scope: any): any;
            get(fn: any): any;
            getDefault(scope: any, init: any): any;
            index(options: any): any;
            ref(ref: any): any;
            required(required: any, message: any): any;
            select(val: any): any;
            set(fn: any): any;
            sparse(bool: any): any;
            text(bool: any): any;
            unique(bool: any): any;
            validate(obj: any, message: any, type: any, ...args: any[]): any;
        }
        class Buffer {
            static checkRequired(fn: any, ...args: any[]): any;
            static schemaName: string;
            constructor(key: any, options: any);
            applyGetters(value: any, scope: any): any;
            applySetters(value: any, scope: any, init: any, priorVal: any, options: any): any;
            cast(value: any, doc: any, init: any): any;
            castForQuery($conditional: any, val: any, ...args: any[]): any;
            castForQueryWrapper(params: any): any;
            checkRequired(value: any, doc: any): any;
            doValidate(value: any, fn: any, scope: any): any;
            doValidateSync(value: any, scope: any): any;
            get(fn: any): any;
            getDefault(scope: any, init: any): any;
            index(options: any): any;
            ref(ref: any): any;
            required(required: any, message: any): any;
            select(val: any): any;
            set(fn: any): any;
            sparse(bool: any): any;
            subtype(subtype: any): any;
            text(bool: any): any;
            unique(bool: any): any;
            validate(obj: any, message: any, type: any, ...args: any[]): any;
        }
        class Date {
            static cast(caster: any, ...args: any[]): any;
            static checkRequired(fn: any, ...args: any[]): any;
            static schemaName: string;
            constructor(key: any, options: any);
            applyGetters(value: any, scope: any): any;
            applySetters(value: any, scope: any, init: any, priorVal: any, options: any): any;
            cast(value: any): any;
            castForQuery($conditional: any, val: any, ...args: any[]): any;
            castForQueryWrapper(params: any): any;
            checkRequired(value: any, doc: any): any;
            doValidate(value: any, fn: any, scope: any): any;
            doValidateSync(value: any, scope: any): any;
            expires(when: any): any;
            get(fn: any): any;
            getDefault(scope: any, init: any): any;
            index(options: any): any;
            max(value: any, message: any): any;
            min(value: any, message: any): any;
            ref(ref: any): any;
            required(required: any, message: any): any;
            select(val: any): any;
            set(fn: any): any;
            sparse(bool: any): any;
            text(bool: any): any;
            unique(bool: any): any;
            validate(obj: any, message: any, type: any, ...args: any[]): any;
        }
        class Decimal {
            static cast(caster: any, ...args: any[]): any;
            static checkRequired(fn: any, ...args: any[]): any;
            static schemaName: string;
            constructor(key: any, options: any);
            applyGetters(value: any, scope: any): any;
            applySetters(value: any, scope: any, init: any, priorVal: any, options: any): any;
            cast(value: any, doc: any, init: any): any;
            castForQuery($conditional: any, val: any, ...args: any[]): any;
            castForQueryWrapper(params: any): any;
            checkRequired(value: any, doc: any): any;
            doValidate(value: any, fn: any, scope: any): any;
            doValidateSync(value: any, scope: any): any;
            get(fn: any): any;
            getDefault(scope: any, init: any): any;
            index(options: any): any;
            ref(ref: any): any;
            required(required: any, message: any): any;
            select(val: any): any;
            set(fn: any): any;
            sparse(bool: any): any;
            text(bool: any): any;
            unique(bool: any): any;
            validate(obj: any, message: any, type: any, ...args: any[]): any;
        }
        class Decimal128 {
            static cast(caster: any, ...args: any[]): any;
            static checkRequired(fn: any, ...args: any[]): any;
            static schemaName: string;
            constructor(key: any, options: any);
            applyGetters(value: any, scope: any): any;
            applySetters(value: any, scope: any, init: any, priorVal: any, options: any): any;
            cast(value: any, doc: any, init: any): any;
            castForQuery($conditional: any, val: any, ...args: any[]): any;
            castForQueryWrapper(params: any): any;
            checkRequired(value: any, doc: any): any;
            doValidate(value: any, fn: any, scope: any): any;
            doValidateSync(value: any, scope: any): any;
            get(fn: any): any;
            getDefault(scope: any, init: any): any;
            index(options: any): any;
            ref(ref: any): any;
            required(required: any, message: any): any;
            select(val: any): any;
            set(fn: any): any;
            sparse(bool: any): any;
            text(bool: any): any;
            unique(bool: any): any;
            validate(obj: any, message: any, type: any, ...args: any[]): any;
        }
        class DocumentArray {
            static schemaName: string;
            constructor(key: any, schema: any, options: any, schemaOptions: any);
            schema: any;
            schemaOptions: any;
            $isMongooseDocumentArray: any;
            applyGetters(value: any, scope: any): any;
            applySetters(value: any, scope: any, init: any, priorVal: any, options: any): any;
            cast(value: any, doc: any, init: any, prev: any, options: any): any;
            castForQuery($conditional: any, value: any, ...args: any[]): any;
            castForQueryWrapper(params: any): any;
            checkRequired(val: any): any;
            discriminator(name: any, schema: any): any;
            doValidate(array: any, fn: any, scope: any, options: any): any;
            doValidateSync(array: any, scope: any): any;
            get(fn: any): any;
            getDefault(scope: any, init: any): any;
            index(options: any): any;
            ref(ref: any): any;
            required(required: any, message: any): any;
            select(val: any): any;
            set(fn: any): any;
            sparse(bool: any): any;
            text(bool: any): any;
            unique(bool: any): any;
            validate(obj: any, message: any, type: any, ...args: any[]): any;
        }
        class Embedded {
            constructor(schema: any, path: any, options: any);
            caster: any;
            schema: any;
            $isSingleNested: any;
            applyGetters(value: any, scope: any): any;
            applySetters(value: any, scope: any, init: any, priorVal: any, options: any): any;
            cast(val: any, doc: any, init: any, priorVal: any): any;
            castForQuery($conditional: any, val: any, ...args: any[]): any;
            castForQueryWrapper(params: any): any;
            checkRequired(val: any): any;
            discriminator(name: any, schema: any): any;
            doValidate(value: any, fn: any, scope: any, options: any): any;
            doValidateSync(value: any, scope: any, options: any): any;
            get(fn: any): any;
            getDefault(scope: any, init: any): any;
            index(options: any): any;
            ref(ref: any): any;
            required(required: any, message: any): any;
            select(val: any): any;
            set(fn: any): any;
            sparse(bool: any): any;
            text(bool: any): any;
            unique(bool: any): any;
            validate(obj: any, message: any, type: any, ...args: any[]): any;
        }
        class Map {
            static CastError(type: any, value: any, path: any, reason: any): void;
            static ValidatorError(properties: any): void;
            static checkRequired(fn: any, ...args: any[]): any;
            static get(getter: any): void;
            constructor(key: any, options: any);
            $isSchemaMap: any;
            applyGetters(value: any, scope: any): any;
            applySetters(value: any, scope: any, init: any, priorVal: any, options: any): any;
            cast(val: any, doc: any, init: any): any;
            castForQuery($conditional: any, val: any, ...args: any[]): any;
            castForQueryWrapper(params: any): any;
            checkRequired(val: any): any;
            doValidate(value: any, fn: any, scope: any): any;
            doValidateSync(value: any, scope: any): any;
            get(fn: any): any;
            getDefault(scope: any, init: any): any;
            index(options: any): any;
            ref(ref: any): any;
            required(required: any, message: any): any;
            select(val: any): any;
            set(fn: any): any;
            sparse(bool: any): any;
            text(bool: any): any;
            unique(bool: any): any;
            validate(obj: any, message: any, type: any, ...args: any[]): any;
        }
        class Mixed {
            static get(getter: any): void;
            static schemaName: string;
            constructor(path: any, options: any);
            applyGetters(value: any, scope: any): any;
            applySetters(value: any, scope: any, init: any, priorVal: any, options: any): any;
            cast(val: any): any;
            castForQuery($cond: any, val: any, ...args: any[]): any;
            castForQueryWrapper(params: any): any;
            checkRequired(val: any): any;
            doValidate(value: any, fn: any, scope: any): any;
            doValidateSync(value: any, scope: any): any;
            get(fn: any): any;
            getDefault(scope: any, init: any): any;
            index(options: any): any;
            ref(ref: any): any;
            required(required: any, message: any): any;
            select(val: any): any;
            set(fn: any): any;
            sparse(bool: any): any;
            text(bool: any): any;
            unique(bool: any): any;
            validate(obj: any, message: any, type: any, ...args: any[]): any;
        }
        class Number {
            static cast(caster: any, ...args: any[]): any;
            static checkRequired(fn: any, ...args: any[]): any;
            static get(getter: any): void;
            static schemaName: string;
            constructor(key: any, options: any);
            applyGetters(value: any, scope: any): any;
            applySetters(value: any, scope: any, init: any, priorVal: any, options: any): any;
            cast(value: any, doc: any, init: any): any;
            castForQuery($conditional: any, val: any, ...args: any[]): any;
            castForQueryWrapper(params: any): any;
            checkRequired(value: any, doc: any): any;
            doValidate(value: any, fn: any, scope: any): any;
            doValidateSync(value: any, scope: any): any;
            get(fn: any): any;
            getDefault(scope: any, init: any): any;
            index(options: any): any;
            max(value: any, message: any): any;
            min(value: any, message: any): any;
            ref(ref: any): any;
            required(required: any, message: any): any;
            select(val: any): any;
            set(fn: any): any;
            sparse(bool: any): any;
            text(bool: any): any;
            unique(bool: any): any;
            validate(obj: any, message: any, type: any, ...args: any[]): any;
        }
        class Object {
            static get(getter: any): void;
            static schemaName: string;
            constructor(path: any, options: any);
            applyGetters(value: any, scope: any): any;
            applySetters(value: any, scope: any, init: any, priorVal: any, options: any): any;
            cast(val: any): any;
            castForQuery($cond: any, val: any, ...args: any[]): any;
            castForQueryWrapper(params: any): any;
            checkRequired(val: any): any;
            doValidate(value: any, fn: any, scope: any): any;
            doValidateSync(value: any, scope: any): any;
            get(fn: any): any;
            getDefault(scope: any, init: any): any;
            index(options: any): any;
            ref(ref: any): any;
            required(required: any, message: any): any;
            select(val: any): any;
            set(fn: any): any;
            sparse(bool: any): any;
            text(bool: any): any;
            unique(bool: any): any;
            validate(obj: any, message: any, type: any, ...args: any[]): any;
        }
        class ObjectId {
            static cast(caster: any, ...args: any[]): any;
            static checkRequired(fn: any, ...args: any[]): any;
            static get(getter: any): void;
            static schemaName: string;
            constructor(key: any, options: any);
            applyGetters(value: any, scope: any): any;
            applySetters(value: any, scope: any, init: any, priorVal: any, options: any): any;
            auto(turnOn: any): any;
            cast(value: any, doc: any, init: any): any;
            castForQuery($conditional: any, val: any, ...args: any[]): any;
            castForQueryWrapper(params: any): any;
            checkRequired(value: any, doc: any): any;
            doValidate(value: any, fn: any, scope: any): any;
            doValidateSync(value: any, scope: any): any;
            get(fn: any): any;
            getDefault(scope: any, init: any): any;
            index(options: any): any;
            ref(ref: any): any;
            required(required: any, message: any): any;
            select(val: any): any;
            set(fn: any): any;
            sparse(bool: any): any;
            text(bool: any): any;
            unique(bool: any): any;
            validate(obj: any, message: any, type: any, ...args: any[]): any;
        }
        class Oid {
            static cast(caster: any, ...args: any[]): any;
            static checkRequired(fn: any, ...args: any[]): any;
            static get(getter: any): void;
            static schemaName: string;
            constructor(key: any, options: any);
            applyGetters(value: any, scope: any): any;
            applySetters(value: any, scope: any, init: any, priorVal: any, options: any): any;
            auto(turnOn: any): any;
            cast(value: any, doc: any, init: any): any;
            castForQuery($conditional: any, val: any, ...args: any[]): any;
            castForQueryWrapper(params: any): any;
            checkRequired(value: any, doc: any): any;
            doValidate(value: any, fn: any, scope: any): any;
            doValidateSync(value: any, scope: any): any;
            get(fn: any): any;
            getDefault(scope: any, init: any): any;
            index(options: any): any;
            ref(ref: any): any;
            required(required: any, message: any): any;
            select(val: any): any;
            set(fn: any): any;
            sparse(bool: any): any;
            text(bool: any): any;
            unique(bool: any): any;
            validate(obj: any, message: any, type: any, ...args: any[]): any;
        }
        class String {
            static cast(caster: any, ...args: any[]): any;
            static checkRequired(fn: any, ...args: any[]): any;
            static get(getter: any): void;
            static schemaName: string;
            constructor(key: any, options: any);
            enumValues: any;
            regExp: any;
            applyGetters(value: any, scope: any): any;
            applySetters(value: any, scope: any, init: any, priorVal: any, options: any): any;
            cast(value: any, doc: any, init: any): any;
            castForQuery($conditional: any, val: any, ...args: any[]): any;
            castForQueryWrapper(params: any): any;
            checkRequired(value: any, doc: any): any;
            doValidate(value: any, fn: any, scope: any): any;
            doValidateSync(value: any, scope: any): any;
            get(fn: any): any;
            getDefault(scope: any, init: any): any;
            index(options: any): any;
            lowercase(shouldApply: any, ...args: any[]): any;
            match(regExp: any, message: any): any;
            maxlength(value: any, message: any): any;
            minlength(value: any, message: any): any;
            ref(ref: any): any;
            required(required: any, message: any): any;
            select(val: any): any;
            set(fn: any): any;
            sparse(bool: any): any;
            text(bool: any): any;
            trim(shouldTrim: any, ...args: any[]): any;
            unique(bool: any): any;
            uppercase(shouldApply: any, ...args: any[]): any;
            validate(obj: any, message: any, type: any, ...args: any[]): any;
        }
    }
}
export class SchemaType {
    static CastError(type: any, value: any, path: any, reason: any): void;
    static ValidatorError(properties: any): void;
    static checkRequired(fn: any, ...args: any[]): any;
    static get(getter: any): void;
    constructor(path: any, options: any, instance: any);
    path: any;
    instance: any;
    validators: any;
    getters: any;
    setters: any;
    options: any;
    applyGetters(value: any, scope: any): any;
    applySetters(value: any, scope: any, init: any, priorVal: any, options: any): any;
    castForQuery($conditional: any, val: any, ...args: any[]): any;
    castForQueryWrapper(params: any): any;
    checkRequired(val: any): any;
    doValidate(value: any, fn: any, scope: any): any;
    doValidateSync(value: any, scope: any): any;
    get(fn: any): any;
    getDefault(scope: any, init: any): any;
    index(options: any): any;
    ref(ref: any): any;
    required(required: any, message: any): any;
    select(val: any): any;
    set(fn: any): any;
    sparse(bool: any): any;
    text(bool: any): any;
    unique(bool: any): any;
    validate(obj: any, message: any, type: any, ...args: any[]): any;
}
export namespace SchemaTypes {
    class Array {
        static schemaName: string;
        constructor(key: any, cast: any, options: any, schemaOptions: any);
        casterConstructor: any;
        caster: any;
        caster: any;
        $isMongooseArray: any;
        applyGetters(value: any, scope: any): any;
        applySetters(value: any, scope: any, init: any, priorVal: any, options: any): any;
        cast(value: any, doc: any, init: any): any;
        castForQuery($conditional: any, value: any, ...args: any[]): any;
        castForQueryWrapper(params: any): any;
        checkRequired(val: any): any;
        discriminator(name: any, schema: any): any;
        doValidate(value: any, fn: any, scope: any): any;
        doValidateSync(value: any, scope: any): any;
        get(fn: any): any;
        getDefault(scope: any, init: any): any;
        index(options: any): any;
        ref(ref: any): any;
        required(required: any, message: any): any;
        select(val: any): any;
        set(fn: any): any;
        sparse(bool: any): any;
        text(bool: any): any;
        unique(bool: any): any;
        validate(obj: any, message: any, type: any, ...args: any[]): any;
    }
    class Bool {
        static cast(caster: any, ...args: any[]): any;
        static checkRequired(fn: any, ...args: any[]): any;
        static convertToFalse: any;
        static convertToTrue: any;
        static schemaName: string;
        constructor(path: any, options: any);
        applyGetters(value: any, scope: any): any;
        applySetters(value: any, scope: any, init: any, priorVal: any, options: any): any;
        cast(value: any): any;
        castForQuery($conditional: any, val: any, ...args: any[]): any;
        castForQueryWrapper(params: any): any;
        checkRequired(value: any): any;
        doValidate(value: any, fn: any, scope: any): any;
        doValidateSync(value: any, scope: any): any;
        get(fn: any): any;
        getDefault(scope: any, init: any): any;
        index(options: any): any;
        ref(ref: any): any;
        required(required: any, message: any): any;
        select(val: any): any;
        set(fn: any): any;
        sparse(bool: any): any;
        text(bool: any): any;
        unique(bool: any): any;
        validate(obj: any, message: any, type: any, ...args: any[]): any;
    }
    namespace Bool {
        namespace $conditionalHandlers {
            function $all(val: any): any;
            function $eq(val: any): any;
            function $exists(val: any): any;
            function $in(val: any): any;
            function $ne(val: any): any;
            function $nin(val: any): any;
            function $type(val: any): any;
        }
    }
    class Boolean {
        static cast(caster: any, ...args: any[]): any;
        static checkRequired(fn: any, ...args: any[]): any;
        static convertToFalse: any;
        static convertToTrue: any;
        static schemaName: string;
        constructor(path: any, options: any);
        applyGetters(value: any, scope: any): any;
        applySetters(value: any, scope: any, init: any, priorVal: any, options: any): any;
        cast(value: any): any;
        castForQuery($conditional: any, val: any, ...args: any[]): any;
        castForQueryWrapper(params: any): any;
        checkRequired(value: any): any;
        doValidate(value: any, fn: any, scope: any): any;
        doValidateSync(value: any, scope: any): any;
        get(fn: any): any;
        getDefault(scope: any, init: any): any;
        index(options: any): any;
        ref(ref: any): any;
        required(required: any, message: any): any;
        select(val: any): any;
        set(fn: any): any;
        sparse(bool: any): any;
        text(bool: any): any;
        unique(bool: any): any;
        validate(obj: any, message: any, type: any, ...args: any[]): any;
    }
    namespace Boolean {
        namespace $conditionalHandlers {
            function $all(val: any): any;
            function $eq(val: any): any;
            function $exists(val: any): any;
            function $in(val: any): any;
            function $ne(val: any): any;
            function $nin(val: any): any;
            function $type(val: any): any;
        }
    }
    class Buffer {
        static checkRequired(fn: any, ...args: any[]): any;
        static schemaName: string;
        constructor(key: any, options: any);
        applyGetters(value: any, scope: any): any;
        applySetters(value: any, scope: any, init: any, priorVal: any, options: any): any;
        cast(value: any, doc: any, init: any): any;
        castForQuery($conditional: any, val: any, ...args: any[]): any;
        castForQueryWrapper(params: any): any;
        checkRequired(value: any, doc: any): any;
        doValidate(value: any, fn: any, scope: any): any;
        doValidateSync(value: any, scope: any): any;
        get(fn: any): any;
        getDefault(scope: any, init: any): any;
        index(options: any): any;
        ref(ref: any): any;
        required(required: any, message: any): any;
        select(val: any): any;
        set(fn: any): any;
        sparse(bool: any): any;
        subtype(subtype: any): any;
        text(bool: any): any;
        unique(bool: any): any;
        validate(obj: any, message: any, type: any, ...args: any[]): any;
    }
    class Date {
        static cast(caster: any, ...args: any[]): any;
        static checkRequired(fn: any, ...args: any[]): any;
        static schemaName: string;
        constructor(key: any, options: any);
        applyGetters(value: any, scope: any): any;
        applySetters(value: any, scope: any, init: any, priorVal: any, options: any): any;
        cast(value: any): any;
        castForQuery($conditional: any, val: any, ...args: any[]): any;
        castForQueryWrapper(params: any): any;
        checkRequired(value: any, doc: any): any;
        doValidate(value: any, fn: any, scope: any): any;
        doValidateSync(value: any, scope: any): any;
        expires(when: any): any;
        get(fn: any): any;
        getDefault(scope: any, init: any): any;
        index(options: any): any;
        max(value: any, message: any): any;
        min(value: any, message: any): any;
        ref(ref: any): any;
        required(required: any, message: any): any;
        select(val: any): any;
        set(fn: any): any;
        sparse(bool: any): any;
        text(bool: any): any;
        unique(bool: any): any;
        validate(obj: any, message: any, type: any, ...args: any[]): any;
    }
    class Decimal {
        static cast(caster: any, ...args: any[]): any;
        static checkRequired(fn: any, ...args: any[]): any;
        static schemaName: string;
        constructor(key: any, options: any);
        applyGetters(value: any, scope: any): any;
        applySetters(value: any, scope: any, init: any, priorVal: any, options: any): any;
        cast(value: any, doc: any, init: any): any;
        castForQuery($conditional: any, val: any, ...args: any[]): any;
        castForQueryWrapper(params: any): any;
        checkRequired(value: any, doc: any): any;
        doValidate(value: any, fn: any, scope: any): any;
        doValidateSync(value: any, scope: any): any;
        get(fn: any): any;
        getDefault(scope: any, init: any): any;
        index(options: any): any;
        ref(ref: any): any;
        required(required: any, message: any): any;
        select(val: any): any;
        set(fn: any): any;
        sparse(bool: any): any;
        text(bool: any): any;
        unique(bool: any): any;
        validate(obj: any, message: any, type: any, ...args: any[]): any;
    }
    class Decimal128 {
        static cast(caster: any, ...args: any[]): any;
        static checkRequired(fn: any, ...args: any[]): any;
        static schemaName: string;
        constructor(key: any, options: any);
        applyGetters(value: any, scope: any): any;
        applySetters(value: any, scope: any, init: any, priorVal: any, options: any): any;
        cast(value: any, doc: any, init: any): any;
        castForQuery($conditional: any, val: any, ...args: any[]): any;
        castForQueryWrapper(params: any): any;
        checkRequired(value: any, doc: any): any;
        doValidate(value: any, fn: any, scope: any): any;
        doValidateSync(value: any, scope: any): any;
        get(fn: any): any;
        getDefault(scope: any, init: any): any;
        index(options: any): any;
        ref(ref: any): any;
        required(required: any, message: any): any;
        select(val: any): any;
        set(fn: any): any;
        sparse(bool: any): any;
        text(bool: any): any;
        unique(bool: any): any;
        validate(obj: any, message: any, type: any, ...args: any[]): any;
    }
    class DocumentArray {
        static schemaName: string;
        constructor(key: any, schema: any, options: any, schemaOptions: any);
        schema: any;
        schemaOptions: any;
        $isMongooseDocumentArray: any;
        applyGetters(value: any, scope: any): any;
        applySetters(value: any, scope: any, init: any, priorVal: any, options: any): any;
        cast(value: any, doc: any, init: any, prev: any, options: any): any;
        castForQuery($conditional: any, value: any, ...args: any[]): any;
        castForQueryWrapper(params: any): any;
        checkRequired(val: any): any;
        discriminator(name: any, schema: any): any;
        doValidate(array: any, fn: any, scope: any, options: any): any;
        doValidateSync(array: any, scope: any): any;
        get(fn: any): any;
        getDefault(scope: any, init: any): any;
        index(options: any): any;
        ref(ref: any): any;
        required(required: any, message: any): any;
        select(val: any): any;
        set(fn: any): any;
        sparse(bool: any): any;
        text(bool: any): any;
        unique(bool: any): any;
        validate(obj: any, message: any, type: any, ...args: any[]): any;
    }
    class Embedded {
        constructor(schema: any, path: any, options: any);
        caster: any;
        schema: any;
        $isSingleNested: any;
        applyGetters(value: any, scope: any): any;
        applySetters(value: any, scope: any, init: any, priorVal: any, options: any): any;
        cast(val: any, doc: any, init: any, priorVal: any): any;
        castForQuery($conditional: any, val: any, ...args: any[]): any;
        castForQueryWrapper(params: any): any;
        checkRequired(val: any): any;
        discriminator(name: any, schema: any): any;
        doValidate(value: any, fn: any, scope: any, options: any): any;
        doValidateSync(value: any, scope: any, options: any): any;
        get(fn: any): any;
        getDefault(scope: any, init: any): any;
        index(options: any): any;
        ref(ref: any): any;
        required(required: any, message: any): any;
        select(val: any): any;
        set(fn: any): any;
        sparse(bool: any): any;
        text(bool: any): any;
        unique(bool: any): any;
        validate(obj: any, message: any, type: any, ...args: any[]): any;
    }
    class Map {
        static CastError(type: any, value: any, path: any, reason: any): void;
        static ValidatorError(properties: any): void;
        static checkRequired(fn: any, ...args: any[]): any;
        static get(getter: any): void;
        constructor(key: any, options: any);
        $isSchemaMap: any;
        applyGetters(value: any, scope: any): any;
        applySetters(value: any, scope: any, init: any, priorVal: any, options: any): any;
        cast(val: any, doc: any, init: any): any;
        castForQuery($conditional: any, val: any, ...args: any[]): any;
        castForQueryWrapper(params: any): any;
        checkRequired(val: any): any;
        doValidate(value: any, fn: any, scope: any): any;
        doValidateSync(value: any, scope: any): any;
        get(fn: any): any;
        getDefault(scope: any, init: any): any;
        index(options: any): any;
        ref(ref: any): any;
        required(required: any, message: any): any;
        select(val: any): any;
        set(fn: any): any;
        sparse(bool: any): any;
        text(bool: any): any;
        unique(bool: any): any;
        validate(obj: any, message: any, type: any, ...args: any[]): any;
    }
    class Mixed {
        static get(getter: any): void;
        static schemaName: string;
        constructor(path: any, options: any);
        applyGetters(value: any, scope: any): any;
        applySetters(value: any, scope: any, init: any, priorVal: any, options: any): any;
        cast(val: any): any;
        castForQuery($cond: any, val: any, ...args: any[]): any;
        castForQueryWrapper(params: any): any;
        checkRequired(val: any): any;
        doValidate(value: any, fn: any, scope: any): any;
        doValidateSync(value: any, scope: any): any;
        get(fn: any): any;
        getDefault(scope: any, init: any): any;
        index(options: any): any;
        ref(ref: any): any;
        required(required: any, message: any): any;
        select(val: any): any;
        set(fn: any): any;
        sparse(bool: any): any;
        text(bool: any): any;
        unique(bool: any): any;
        validate(obj: any, message: any, type: any, ...args: any[]): any;
    }
    class Number {
        static cast(caster: any, ...args: any[]): any;
        static checkRequired(fn: any, ...args: any[]): any;
        static get(getter: any): void;
        static schemaName: string;
        constructor(key: any, options: any);
        applyGetters(value: any, scope: any): any;
        applySetters(value: any, scope: any, init: any, priorVal: any, options: any): any;
        cast(value: any, doc: any, init: any): any;
        castForQuery($conditional: any, val: any, ...args: any[]): any;
        castForQueryWrapper(params: any): any;
        checkRequired(value: any, doc: any): any;
        doValidate(value: any, fn: any, scope: any): any;
        doValidateSync(value: any, scope: any): any;
        get(fn: any): any;
        getDefault(scope: any, init: any): any;
        index(options: any): any;
        max(value: any, message: any): any;
        min(value: any, message: any): any;
        ref(ref: any): any;
        required(required: any, message: any): any;
        select(val: any): any;
        set(fn: any): any;
        sparse(bool: any): any;
        text(bool: any): any;
        unique(bool: any): any;
        validate(obj: any, message: any, type: any, ...args: any[]): any;
    }
    class Object {
        static get(getter: any): void;
        static schemaName: string;
        constructor(path: any, options: any);
        applyGetters(value: any, scope: any): any;
        applySetters(value: any, scope: any, init: any, priorVal: any, options: any): any;
        cast(val: any): any;
        castForQuery($cond: any, val: any, ...args: any[]): any;
        castForQueryWrapper(params: any): any;
        checkRequired(val: any): any;
        doValidate(value: any, fn: any, scope: any): any;
        doValidateSync(value: any, scope: any): any;
        get(fn: any): any;
        getDefault(scope: any, init: any): any;
        index(options: any): any;
        ref(ref: any): any;
        required(required: any, message: any): any;
        select(val: any): any;
        set(fn: any): any;
        sparse(bool: any): any;
        text(bool: any): any;
        unique(bool: any): any;
        validate(obj: any, message: any, type: any, ...args: any[]): any;
    }
    class ObjectId {
        static cast(caster: any, ...args: any[]): any;
        static checkRequired(fn: any, ...args: any[]): any;
        static get(getter: any): void;
        static schemaName: string;
        constructor(key: any, options: any);
        applyGetters(value: any, scope: any): any;
        applySetters(value: any, scope: any, init: any, priorVal: any, options: any): any;
        auto(turnOn: any): any;
        cast(value: any, doc: any, init: any): any;
        castForQuery($conditional: any, val: any, ...args: any[]): any;
        castForQueryWrapper(params: any): any;
        checkRequired(value: any, doc: any): any;
        doValidate(value: any, fn: any, scope: any): any;
        doValidateSync(value: any, scope: any): any;
        get(fn: any): any;
        getDefault(scope: any, init: any): any;
        index(options: any): any;
        ref(ref: any): any;
        required(required: any, message: any): any;
        select(val: any): any;
        set(fn: any): any;
        sparse(bool: any): any;
        text(bool: any): any;
        unique(bool: any): any;
        validate(obj: any, message: any, type: any, ...args: any[]): any;
    }
    class Oid {
        static cast(caster: any, ...args: any[]): any;
        static checkRequired(fn: any, ...args: any[]): any;
        static get(getter: any): void;
        static schemaName: string;
        constructor(key: any, options: any);
        applyGetters(value: any, scope: any): any;
        applySetters(value: any, scope: any, init: any, priorVal: any, options: any): any;
        auto(turnOn: any): any;
        cast(value: any, doc: any, init: any): any;
        castForQuery($conditional: any, val: any, ...args: any[]): any;
        castForQueryWrapper(params: any): any;
        checkRequired(value: any, doc: any): any;
        doValidate(value: any, fn: any, scope: any): any;
        doValidateSync(value: any, scope: any): any;
        get(fn: any): any;
        getDefault(scope: any, init: any): any;
        index(options: any): any;
        ref(ref: any): any;
        required(required: any, message: any): any;
        select(val: any): any;
        set(fn: any): any;
        sparse(bool: any): any;
        text(bool: any): any;
        unique(bool: any): any;
        validate(obj: any, message: any, type: any, ...args: any[]): any;
    }
    class String {
        static cast(caster: any, ...args: any[]): any;
        static checkRequired(fn: any, ...args: any[]): any;
        static get(getter: any): void;
        static schemaName: string;
        constructor(key: any, options: any);
        enumValues: any;
        regExp: any;
        applyGetters(value: any, scope: any): any;
        applySetters(value: any, scope: any, init: any, priorVal: any, options: any): any;
        cast(value: any, doc: any, init: any): any;
        castForQuery($conditional: any, val: any, ...args: any[]): any;
        castForQueryWrapper(params: any): any;
        checkRequired(value: any, doc: any): any;
        doValidate(value: any, fn: any, scope: any): any;
        doValidateSync(value: any, scope: any): any;
        get(fn: any): any;
        getDefault(scope: any, init: any): any;
        index(options: any): any;
        lowercase(shouldApply: any, ...args: any[]): any;
        match(regExp: any, message: any): any;
        maxlength(value: any, message: any): any;
        minlength(value: any, message: any): any;
        ref(ref: any): any;
        required(required: any, message: any): any;
        select(val: any): any;
        set(fn: any): any;
        sparse(bool: any): any;
        text(bool: any): any;
        trim(shouldTrim: any, ...args: any[]): any;
        unique(bool: any): any;
        uppercase(shouldApply: any, ...args: any[]): any;
        validate(obj: any, message: any, type: any, ...args: any[]): any;
    }
}
export namespace Types {
    function Array(values: any, path: any, doc: any): any;
    namespace Array {
        namespace mixin {
            function $__getAtomics(): any;
            function $pop(): any;
            function $shift(): any;
            function addToSet(...args: any[]): any;
            function hasAtomics(): any;
            function indexOf(obj: any): any;
            function inspect(): any;
            function nonAtomicPush(...args: any[]): any;
            function pop(): any;
            function pull(...args: any[]): any;
            function push(...args: any[]): any;
            function remove(...args: any[]): any;
            function set(i: any, val: any): any;
            function shift(): any;
            function sort(...args: any[]): any;
            function splice(...args: any[]): any;
            function toBSON(): any;
            function toObject(options: any): any;
            function unshift(...args: any[]): any;
        }
    }
    function Buffer(value: any, encode: any, offset: any, ...args: any[]): any;
    namespace Buffer {
        class Binary {
            static BUFFER_SIZE: number;
            // Circular reference from index.Types.Buffer.Binary
            static Binary: any;
            static SUBTYPE_BYTE_ARRAY: number;
            static SUBTYPE_DEFAULT: number;
            static SUBTYPE_FUNCTION: number;
            static SUBTYPE_MD5: number;
            static SUBTYPE_USER_DEFINED: number;
            static SUBTYPE_UUID: number;
            static SUBTYPE_UUID_OLD: number;
            constructor(buffer: any, subType: any);
            sub_type: any;
            position: any;
            sub_type: any;
            position: any;
            buffer: any;
            buffer: any;
            buffer: any;
            position: any;
            buffer: any;
            buffer: any;
            buffer: any;
            position: any;
            length(): any;
            put(byte_value: any): void;
            read(position: any, length: any): any;
            toJSON(): any;
            toString(format: any): any;
            value(asRaw: any): any;
            write(string: any, offset: any): void;
        }
        namespace mixin {
            function asciiWrite(...args: any[]): any;
            function copy(target: any, ...args: any[]): any;
            function equals(other: any): any;
            function fill(...args: any[]): any;
            function set(...args: any[]): any;
            function subtype(subtype: any): void;
            function toBSON(): any;
            function toObject(options: any): any;
            function utf8Write(...args: any[]): any;
            function write(...args: any[]): any;
            function writeDoubleBE(...args: any[]): any;
            function writeDoubleLE(...args: any[]): any;
            function writeFloatBE(...args: any[]): any;
            function writeFloatLE(...args: any[]): any;
            function writeInt16BE(...args: any[]): any;
            function writeInt16LE(...args: any[]): any;
            function writeInt32BE(...args: any[]): any;
            function writeInt32LE(...args: any[]): any;
            function writeInt8(...args: any[]): any;
            function writeUInt16BE(...args: any[]): any;
            function writeUInt16LE(...args: any[]): any;
            function writeUInt32BE(...args: any[]): any;
            function writeUInt32LE(...args: any[]): any;
            function writeUInt8(...args: any[]): any;
        }
    }
    class Decimal128 {
        // Circular reference from index.Types.Decimal128
        static Decimal128: any;
        static fromString(string: any): any;
        constructor(bytes: any);
        bytes: any;
        toJSON(): any;
    }
    class Document {
        static addListener(type: any, listener: any): any;
        static domain: any;
        static emit(type: any, ...args: any[]): any;
        static eventNames(): any;
        static getMaxListeners(): any;
        static listenerCount(type: any): any;
        static listeners(type: any): any;
        static on(type: any, listener: any): any;
        static once(type: any, listener: any): any;
        static prependListener(type: any, listener: any): any;
        static prependOnceListener(type: any, listener: any): any;
        static removeAllListeners(type: any, ...args: any[]): any;
        static removeListener(type: any, listener: any): any;
        static setMaxListeners(n: any): any;
        constructor(obj: any, parentArr: any, skipId: any, fields: any, index: any);
        $isDocumentArrayElement: any;
        $__buildDoc(obj: any, fields: any, skipId: any, exclude: any, hasIncludedChildren: any): void;
        $__dirty(): any;
        $__fullPath(path: any): any;
        $__getAllSubdocs(): any;
        $__getArrayPathsToValidate(): any;
        $__handleReject(err: any): void;
        $__init(doc: any, opts: any): any;
        $__path(path: any): any;
        $__remove(cb: any): any;
        $__reset(): any;
        $__save(fn: any): any;
        $__set(pathToMark: any, path: any, constructing: any, parts: any, schema: any, val: any, priorVal: any): void;
        $__setSchema(schema: any): void;
        $__shouldModify(pathToMark: any, path: any, constructing: any, parts: any, schema: any, val: any, priorVal: any): any;
        $__updateOne(doc: any, options: any, callback: any): any;
        $__validate(callback: any): any;
        $ignore(path: any): void;
        $isDefault(path: any): any;
        $isDeleted(val: any, ...args: any[]): any;
        $isValid(path: any): any;
        $markValid(path: any): void;
        $session(session: any, ...args: any[]): any;
        $set(path: any, val: any, type: any, options: any): any;
        $setIndex(index: any): void;
        $toObject(options: any, json: any): any;
        addListener(...args: any[]): any;
        depopulate(path: any, ...args: any[]): any;
        emit(...args: any[]): any;
        equals(doc: any): any;
        execPopulate(callback: any): any;
        get(path: any, type: any, options: any): any;
        getValue(path: any): any;
        init(doc: any, opts: any, fn: any): any;
        inspect(): any;
        invalidate(path: any, err: any, val: any): any;
        isDirectModified(path: any): any;
        isDirectSelected(path: any): any;
        isInit(path: any): any;
        isModified(paths: any, modifiedPaths: any): any;
        isSelected(path: any): any;
        listeners(...args: any[]): any;
        markModified(path: any): void;
        modifiedPaths(options: any): any;
        on(...args: any[]): any;
        once(...args: any[]): any;
        ownerDocument(): any;
        parent(): any;
        parentArray(): any;
        populate(): void;
        populated(path: any, val: any, options: any): any;
        remove(options: any, fn: any): any;
        removeAllListeners(...args: any[]): any;
        removeListener(...args: any[]): any;
        replaceOne(...args: any[]): any;
        save(options: any, fn: any): any;
        set(path: any, val: any, type: any, options: any): any;
        setMaxListeners(...args: any[]): any;
        setValue(path: any, val: any): any;
        toBSON(): any;
        toJSON(options: any): any;
        toObject(options: any): any;
        unmarkModified(path: any): void;
        update(): void;
        updateOne(doc: any, options: any, callback: any): any;
        validate(options: any, callback: any): any;
        validateSync(pathsToValidate: any): any;
    }
    function DocumentArray(values: any, path: any, doc: any): any;
    namespace DocumentArray {
        namespace mixin {
            function create(obj: any): any;
            function id(id: any): any;
            function inspect(): any;
            function notify(event: any): any;
            function toBSON(): any;
            function toObject(options: any): any;
        }
    }
    class Embedded {
        static addListener(type: any, listener: any): any;
        static domain: any;
        static emit(type: any, ...args: any[]): any;
        static eventNames(): any;
        static getMaxListeners(): any;
        static listenerCount(type: any): any;
        static listeners(type: any): any;
        static on(type: any, listener: any): any;
        static once(type: any, listener: any): any;
        static prependListener(type: any, listener: any): any;
        static prependOnceListener(type: any, listener: any): any;
        static removeAllListeners(type: any, ...args: any[]): any;
        static removeListener(type: any, listener: any): any;
        static setMaxListeners(n: any): any;
        constructor(obj: any, parentArr: any, skipId: any, fields: any, index: any);
        $isDocumentArrayElement: any;
        $__buildDoc(obj: any, fields: any, skipId: any, exclude: any, hasIncludedChildren: any): void;
        $__dirty(): any;
        $__fullPath(path: any): any;
        $__getAllSubdocs(): any;
        $__getArrayPathsToValidate(): any;
        $__handleReject(err: any): void;
        $__init(doc: any, opts: any): any;
        $__path(path: any): any;
        $__remove(cb: any): any;
        $__reset(): any;
        $__save(fn: any): any;
        $__set(pathToMark: any, path: any, constructing: any, parts: any, schema: any, val: any, priorVal: any): void;
        $__setSchema(schema: any): void;
        $__shouldModify(pathToMark: any, path: any, constructing: any, parts: any, schema: any, val: any, priorVal: any): any;
        $__updateOne(doc: any, options: any, callback: any): any;
        $__validate(callback: any): any;
        $ignore(path: any): void;
        $isDefault(path: any): any;
        $isDeleted(val: any, ...args: any[]): any;
        $isValid(path: any): any;
        $markValid(path: any): void;
        $session(session: any, ...args: any[]): any;
        $set(path: any, val: any, type: any, options: any): any;
        $setIndex(index: any): void;
        $toObject(options: any, json: any): any;
        addListener(...args: any[]): any;
        depopulate(path: any, ...args: any[]): any;
        emit(...args: any[]): any;
        equals(doc: any): any;
        execPopulate(callback: any): any;
        get(path: any, type: any, options: any): any;
        getValue(path: any): any;
        init(doc: any, opts: any, fn: any): any;
        inspect(): any;
        invalidate(path: any, err: any, val: any): any;
        isDirectModified(path: any): any;
        isDirectSelected(path: any): any;
        isInit(path: any): any;
        isModified(paths: any, modifiedPaths: any): any;
        isSelected(path: any): any;
        listeners(...args: any[]): any;
        markModified(path: any): void;
        modifiedPaths(options: any): any;
        on(...args: any[]): any;
        once(...args: any[]): any;
        ownerDocument(): any;
        parent(): any;
        parentArray(): any;
        populate(): void;
        populated(path: any, val: any, options: any): any;
        remove(options: any, fn: any): any;
        removeAllListeners(...args: any[]): any;
        removeListener(...args: any[]): any;
        replaceOne(...args: any[]): any;
        save(options: any, fn: any): any;
        set(path: any, val: any, type: any, options: any): any;
        setMaxListeners(...args: any[]): any;
        setValue(path: any, val: any): any;
        toBSON(): any;
        toJSON(options: any): any;
        toObject(options: any): any;
        unmarkModified(path: any): void;
        update(): void;
        updateOne(doc: any, options: any, callback: any): any;
        validate(options: any, callback: any): any;
        validateSync(pathsToValidate: any): any;
    }
    class Map {
        constructor(v: any, path: any, doc: any, schemaType: any);
        $__parent: any;
        $__path: any;
        $__schemaType: any;
        $__runDeferred(): void;
        $__set(key: any, value: any): void;
        $init(key: any, value: any): void;
        clear(): any;
        entries(): any;
        forEach(p0: any): any;
        get(p0: any): any;
        has(p0: any): any;
        inspect(): any;
        keys(): any;
        set(key: any, value: any): void;
        toBSON(): any;
        toJSON(): any;
        toObject(options: any): any;
        values(): any;
    }
    namespace Map {
        class Map {
            // Circular reference from index.Types.Map.Map
            static Map: any;
            clear(): any;
            entries(): any;
            forEach(p0: any): any;
            get(p0: any): any;
            has(p0: any): any;
            keys(): any;
            set(p0: any, p1: any): any;
            values(): any;
        }
    }
    class ObjectId {
        // Circular reference from index.Types.ObjectId
        static ObjectID: any;
        // Circular reference from index.Types.ObjectId
        static ObjectId: any;
        static createFromHexString(string: any): any;
        static createFromTime(time: any): any;
        static createPk(): any;
        static index: number;
        static isValid(id: any): any;
        constructor(id: any);
        id: any;
        id: any;
        equals(otherId: any): any;
        generate(time: any): any;
        getInc(): any;
        getTimestamp(): any;
        get_inc(): any;
        toHexString(): any;
        toJSON(): any;
        toString(format: any): any;
    }
    class Subdocument {
        constructor(value: any, fields: any, parent: any, skipId: any, options: any);
        $isSingleNested: any;
        $__buildDoc(obj: any, fields: any, skipId: any, exclude: any, hasIncludedChildren: any): void;
        $__dirty(): any;
        $__fullPath(path: any): any;
        $__getAllSubdocs(): any;
        $__getArrayPathsToValidate(): any;
        $__handleReject(err: any): void;
        $__init(doc: any, opts: any): any;
        $__path(path: any): any;
        $__remove(cb: any): any;
        $__reset(): any;
        $__save(fn: any): any;
        $__set(pathToMark: any, path: any, constructing: any, parts: any, schema: any, val: any, priorVal: any): void;
        $__setSchema(schema: any): void;
        $__shouldModify(pathToMark: any, path: any, constructing: any, parts: any, schema: any, val: any, priorVal: any): any;
        $__updateOne(doc: any, options: any, callback: any): any;
        $__validate(callback: any): any;
        $ignore(path: any): void;
        $isDefault(path: any): any;
        $isDeleted(val: any, ...args: any[]): any;
        $isValid(path: any): any;
        $markValid(path: any): void;
        $session(session: any, ...args: any[]): any;
        $set(path: any, val: any, type: any, options: any): any;
        $toObject(options: any, json: any): any;
        addListener(...args: any[]): any;
        depopulate(path: any, ...args: any[]): any;
        emit(...args: any[]): any;
        equals(doc: any): any;
        execPopulate(callback: any): any;
        get(path: any, type: any, options: any): any;
        getValue(path: any): any;
        init(doc: any, opts: any, fn: any): any;
        inspect(options: any): any;
        invalidate(path: any, err: any, val: any): void;
        isDirectModified(path: any): any;
        isDirectSelected(path: any): any;
        isInit(path: any): any;
        isModified(paths: any, modifiedPaths: any): any;
        isSelected(path: any): any;
        listeners(...args: any[]): any;
        markModified(path: any): void;
        modifiedPaths(options: any): any;
        on(...args: any[]): any;
        once(...args: any[]): any;
        ownerDocument(): any;
        parent(): any;
        populate(): void;
        populated(path: any, val: any, options: any): any;
        remove(options: any, callback: any): void;
        removeAllListeners(...args: any[]): any;
        removeListener(...args: any[]): any;
        replaceOne(...args: any[]): any;
        save(options: any, fn: any): any;
        set(path: any, val: any, type: any, options: any): any;
        setMaxListeners(...args: any[]): any;
        setValue(path: any, val: any): any;
        toBSON(): any;
        toJSON(options: any): any;
        toObject(options: any): any;
        unmarkModified(path: any): void;
        update(...args: any[]): any;
        updateOne(doc: any, options: any, callback: any): any;
        validate(options: any, callback: any): any;
        validateSync(pathsToValidate: any): any;
    }
}
export class VirtualType {
    constructor(options: any, name: any);
    path: any;
    getters: any;
    setters: any;
    options: any;
    applyGetters(value: any, scope: any): any;
    applySetters(value: any, scope: any): any;
    clone(): any;
    get(fn: any): any;
    set(fn: any): any;
}
export function connect(...args: any[]): any;
export const connection: any;
export const connections: {
    $internalEmitter: {
        addListener: Function;
        domain: {};
        emit: Function;
        eventNames: Function;
        getMaxListeners: Function;
        listenerCount: Function;
        listeners: Function;
        on: Function;
        once: Function;
        prependListener: Function;
        prependOnceListener: Function;
        removeAllListeners: Function;
        removeListener: Function;
        setMaxListeners: Function;
    };
    addListener: Function;
    authMechanismDoesNotRequirePassword: Function;
    base: any;
    close: Function;
    collection: Function;
    collections: {};
    config: {
        autoIndex: boolean;
    };
    createCollection: Function;
    deleteModel: Function;
    doClose: Function;
    domain: any;
    dropCollection: Function;
    dropDatabase: Function;
    emit: Function;
    error: Function;
    eventNames: Function;
    getMaxListeners: Function;
    host: any;
    listenerCount: Function;
    listeners: Function;
    model: Function;
    modelNames: Function;
    models: {};
    on: Function;
    onClose: Function;
    onOpen: Function;
    once: Function;
    openUri: Function;
    options: {};
    optionsProvideAuthenticationData: Function;
    otherDbs: any[];
    pass: any;
    port: any;
    prependListener: Function;
    prependOnceListener: Function;
    readyState: any;
    relatedDbs: {};
    removeAllListeners: Function;
    removeListener: Function;
    replica: boolean;
    setMaxListeners: Function;
    shouldAuthenticate: Function;
    startSession: Function;
    states: {
        0: string;
        1: string;
        2: string;
        3: string;
        99: string;
        connected: number;
        connecting: number;
        disconnected: number;
        disconnecting: number;
        uninitialized: number;
    };
    useDb: Function;
    user: any;
}[];
export function createConnection(uri: any, options: any, callback: any, ...args: any[]): any;
export function deleteModel(name: any): any;
export function disconnect(callback: any): any;
export function get(key: any, value: any, ...args: any[]): any;
export function model(name: any, schema: any, collection: any, skipInit: any): any;
export function modelNames(): any;
export const modelSchemas: {};
export const models: {};
export function mongo(url: any, options: any, callback: any, ...args: any[]): any;
export namespace mongo {
    class Admin {
        constructor(db: any, topology: any, promiseLibrary: any);
        s: any;
        addUser(username: any, password: any, options: any, callback: any, ...args: any[]): any;
        buildInfo(options: any, callback: any): any;
        command(command: any, options: any, callback: any, ...args: any[]): any;
        listDatabases(options: any, callback: any): any;
        ping(options: any, callback: any): any;
        removeUser(username: any, options: any, callback: any, ...args: any[]): any;
        replSetGetStatus(options: any, callback: any): any;
        serverInfo(options: any, callback: any): any;
        serverStatus(options: any, callback: any): any;
        validateCollection(collectionName: any, options: any, callback: any): any;
    }
    class AggregationCursor {
        static CLOSED: number;
        static INIT: number;
        static OPEN: number;
        constructor(bson: any, ns: any, cmd: any, options: any, topology: any, topologyOptions: any, ...args: any[]);
        s: any;
        addCursorFlag(flag: any, value: any): any;
        addListener(ev: any, fn: any): any;
        addQueryModifier(name: any, value: any): any;
        batchSize(value: any): any;
        bufferedCount(): any;
        clone(): any;
        close(options: any, callback: any): any;
        collation(value: any): any;
        comment(value: any): any;
        count(applySkipLimit: any, opts: any, callback: any): any;
        cursorBatchSize(): any;
        cursorLimit(): any;
        cursorSkip(): any;
        destroy(err: any): void;
        each(args: any): any;
        emit(type: any, ...args: any[]): any;
        eventNames(): any;
        explain(callback: any): any;
        filter(filter: any): any;
        forEach(iterator: any, callback: any): any;
        geoNear(document: any): any;
        get(callback: any): any;
        getLogger(): any;
        getMaxListeners(): any;
        group(document: any): any;
        hasNext(callback: any): any;
        hint(hint: any): any;
        isClosed(): any;
        isDead(): any;
        isKilled(): any;
        isNotified(): any;
        isPaused(): any;
        kill(callback: any): void;
        limit(value: any): any;
        listenerCount(type: any): any;
        listeners(type: any): any;
        lookup(document: any): any;
        map(transform: any): any;
        match(document: any): any;
        max(max: any): any;
        maxAwaitTimeMS(value: any): any;
        maxScan(args: any): any;
        maxTimeMS(value: any): any;
        maxTimeMs(value: any): any;
        min(min: any): any;
        next(callback: any): any;
        on(ev: any, fn: any): any;
        once(type: any, listener: any): any;
        out(destination: any): any;
        pause(): any;
        pipe(dest: any, pipeOpts: any): any;
        prependListener(type: any, listener: any): any;
        prependOnceListener(type: any, listener: any): any;
        project(document: any): any;
        push(chunk: any, encoding: any): any;
        read(n: any): any;
        readBufferedDocuments(number: any): any;
        redact(document: any): any;
        removeAllListeners(type: any, ...args: any[]): any;
        removeListener(type: any, listener: any): any;
        resume(): any;
        returnKey(value: any): any;
        rewind(): void;
        setCursorBatchSize(value: any): void;
        setCursorLimit(value: any): void;
        setCursorOption(field: any, value: any): any;
        setCursorSkip(value: any): void;
        setEncoding(enc: any): any;
        setMaxListeners(n: any): any;
        setReadPreference(readPreference: any): any;
        showRecordId(value: any): any;
        skip(value: any): any;
        snapshot(args: any): any;
        sort(document: any): any;
        stream(options: any): any;
        toArray(callback: any): any;
        transformStream(options: any): any;
        unpipe(dest: any): any;
        unshift(chunk: any): any;
        unwind(field: any): any;
        wrap(stream: any): any;
    }
    class BSONRegExp {
        // Circular reference from index.mongo.BSONRegExp
        static BSONRegExp: any;
        constructor(pattern: any, options: any);
        pattern: any;
        options: any;
    }
    class Binary {
        static BUFFER_SIZE: number;
        // Circular reference from index.mongo.Binary
        static Binary: any;
        static SUBTYPE_BYTE_ARRAY: number;
        static SUBTYPE_DEFAULT: number;
        static SUBTYPE_FUNCTION: number;
        static SUBTYPE_MD5: number;
        static SUBTYPE_USER_DEFINED: number;
        static SUBTYPE_UUID: number;
        static SUBTYPE_UUID_OLD: number;
        constructor(buffer: any, subType: any);
        sub_type: any;
        position: any;
        sub_type: any;
        position: any;
        buffer: any;
        buffer: any;
        buffer: any;
        position: any;
        buffer: any;
        buffer: any;
        buffer: any;
        position: any;
        length(): any;
        put(byte_value: any): void;
        read(position: any, length: any): any;
        toJSON(): any;
        toString(format: any): any;
        value(asRaw: any): any;
        write(string: any, offset: any): void;
    }
    class Chunk {
        static DEFAULT_CHUNK_SIZE: number;
        constructor(file: any, mongoObject: any, writeConcern: any);
        file: any;
        writeConcern: any;
        objectId: any;
        chunkNumber: any;
        data: any;
        data: any;
        data: any;
        data: any;
        internalPosition: any;
        buildMongoObject(callback: any): void;
        eof(): any;
        getc(): any;
        length(): any;
        read(length: any): any;
        readSlice(length: any): any;
        rewind(): void;
        save(options: any, callback: any): void;
        write(data: any, callback: any): any;
    }
    class Code {
        // Circular reference from index.mongo.Code
        static Code: any;
        constructor(code: any, scope: any);
        code: any;
        scope: any;
        toJSON(): any;
    }
    class Collection {
        constructor(db: any, topology: any, dbName: any, name: any, pkFactory: any, options: any);
        s: any;
        aggregate(pipeline: any, options: any, callback: any, ...args: any[]): any;
        bulkWrite(operations: any, options: any, callback: any): any;
        count(args: any): any;
        countDocuments(query: any, options: any, callback: any, ...args: any[]): any;
        createIndex(fieldOrSpec: any, options: any, callback: any): any;
        createIndexes(indexSpecs: any, options: any, callback: any): any;
        deleteMany(filter: any, options: any, callback: any): any;
        deleteOne(filter: any, options: any, callback: any): any;
        distinct(key: any, query: any, options: any, callback: any, ...args: any[]): any;
        drop(options: any, callback: any): any;
        dropAllIndexes(args: any): any;
        dropIndex(indexName: any, options: any, callback: any, ...args: any[]): any;
        dropIndexes(options: any, callback: any): any;
        ensureIndex(args: any): any;
        estimatedDocumentCount(options: any, callback: any): any;
        find(...args: any[]): any;
        findAndModify(args: any): any;
        findAndRemove(args: any): any;
        findOne(...args: any[]): any;
        findOneAndDelete(filter: any, options: any, callback: any): any;
        findOneAndReplace(filter: any, replacement: any, options: any, callback: any): any;
        findOneAndUpdate(filter: any, update: any, options: any, callback: any): any;
        geoHaystackSearch(x: any, y: any, options: any, callback: any, ...args: any[]): any;
        getLogger(): any;
        group(args: any): any;
        indexExists(indexes: any, options: any, callback: any): any;
        indexInformation(options: any, callback: any, ...args: any[]): any;
        indexes(options: any, callback: any): any;
        initializeOrderedBulkOp(options: any): any;
        initializeUnorderedBulkOp(options: any): any;
        insert(args: any): any;
        insertMany(docs: any, options: any, callback: any): any;
        insertOne(doc: any, options: any, callback: any): any;
        isCapped(options: any, callback: any): any;
        listIndexes(options: any): any;
        mapReduce(map: any, reduce: any, options: any, callback: any): any;
        options(opts: any, callback: any): any;
        parallelCollectionScan(options: any, callback: any): any;
        reIndex(options: any, callback: any): any;
        remove(args: any): any;
        removeMany(filter: any, options: any, callback: any): any;
        removeOne(filter: any, options: any, callback: any): any;
        rename(newName: any, options: any, callback: any): any;
        replaceOne(filter: any, doc: any, options: any, callback: any): any;
        save(args: any): any;
        stats(options: any, callback: any, ...args: any[]): any;
        update(args: any): any;
        updateMany(filter: any, update: any, options: any, callback: any): any;
        updateOne(filter: any, update: any, options: any, callback: any): any;
        watch(pipeline: any, options: any): any;
    }
    class CommandCursor {
        static CLOSED: number;
        static INIT: number;
        static OPEN: number;
        constructor(bson: any, ns: any, cmd: any, options: any, topology: any, topologyOptions: any, ...args: any[]);
        s: any;
        addListener(ev: any, fn: any): any;
        batchSize(value: any): any;
        bufferedCount(): any;
        close(options: any, callback: any): any;
        destroy(err: any, cb: any): any;
        each(args: any): any;
        emit(type: any, ...args: any[]): any;
        eventNames(): any;
        explain(callback: any): any;
        forEach(iterator: any, callback: any): any;
        get(callback: any): any;
        getLogger(): any;
        getMaxListeners(): any;
        hasNext(callback: any): any;
        isClosed(): any;
        isDead(): any;
        isKilled(): any;
        isNotified(): any;
        isPaused(): any;
        kill(callback: any): void;
        listenerCount(type: any): any;
        listeners(type: any): any;
        maxTimeMS(value: any): any;
        next(callback: any): any;
        on(ev: any, fn: any): any;
        once(type: any, listener: any): any;
        pause(): any;
        pipe(dest: any, pipeOpts: any): any;
        prependListener(type: any, listener: any): any;
        prependOnceListener(type: any, listener: any): any;
        push(chunk: any, encoding: any): any;
        read(n: any): any;
        readBufferedDocuments(number: any): any;
        removeAllListeners(type: any, ...args: any[]): any;
        removeListener(type: any, listener: any): any;
        resume(): any;
        rewind(): void;
        setCursorBatchSize(value: any): void;
        setEncoding(enc: any): any;
        setMaxListeners(n: any): any;
        setReadPreference(readPreference: any): any;
        toArray(callback: any): any;
        unpipe(dest: any): any;
        unshift(chunk: any): any;
        wrap(stream: any): any;
    }
    class CoreConnection {
        static connections(): any;
        static disableConnectionAccounting(): void;
        static enableConnectionAccounting(spy: any): void;
        constructor(messageHandler: any, options: any);
        options: any;
        id: any;
        logger: any;
        bson: any;
        tag: any;
        messageHandler: any;
        maxBsonMessageSize: any;
        port: any;
        host: any;
        family: any;
        keepAlive: any;
        keepAliveInitialDelay: any;
        noDelay: any;
        connectionTimeout: any;
        socketTimeout: any;
        keepAliveInitialDelay: any;
        destroyed: any;
        domainSocket: any;
        singleBufferSerializtion: any;
        serializationFunction: any;
        ca: any;
        crl: any;
        cert: any;
        key: any;
        passphrase: any;
        ciphers: any;
        ecdhCurve: any;
        ssl: any;
        rejectUnauthorized: any;
        checkServerIdentity: any;
        rejectUnauthorized: any;
        responseOptions: any;
        flushing: any;
        queue: any;
        connection: any;
        writeStream: any;
        hashedName: any;
        workItems: any;
        addListener(type: any, listener: any): any;
        connect(_options: any): any;
        destroy(): void;
        emit(type: any, ...args: any[]): any;
        eventNames(): any;
        getMaxListeners(): any;
        isConnected(): any;
        listenerCount(type: any): any;
        listeners(type: any): any;
        on(type: any, listener: any): any;
        once(type: any, listener: any): any;
        prependListener(type: any, listener: any): any;
        prependOnceListener(type: any, listener: any): any;
        removeAllListeners(type: any, ...args: any[]): any;
        removeListener(type: any, listener: any): any;
        resetSocketTimeout(): void;
        setMaxListeners(n: any): any;
        setSocketTimeout(value: any): void;
        toJSON(): any;
        unref(): void;
        write(buffer: any): any;
    }
    class CoreServer {
        static disableServerAccounting(): void;
        static enableServerAccounting(): void;
        static servers(): any;
        constructor(options: any);
        id: any;
        s: any;
        ismaster: any;
        lastIsMasterMS: any;
        monitoringProcessId: any;
        initialConnect: any;
        wireProtocolHandler: any;
        clientInfo: any;
        lastUpdateTime: any;
        lastWriteDate: any;
        staleness: any;
        addListener(type: any, listener: any): any;
        auth(mechanism: any, db: any, ...args: any[]): any;
        command(ns: any, cmd: any, options: any, callback: any): any;
        connect(options: any): void;
        connections(): any;
        cursor(ns: any, cmd: any, options: any): any;
        destroy(options: any): void;
        emit(type: any, ...args: any[]): any;
        endSessions(sessions: any, callback: any): void;
        equals(server: any): any;
        eventNames(): any;
        getDescription(): any;
        getMaxListeners(): any;
        insert(ns: any, ops: any, options: any, callback: any): any;
        isConnected(): any;
        isDestroyed(): any;
        lastIsMaster(): any;
        listenerCount(type: any): any;
        listeners(type: any): any;
        logout(dbName: any, callback: any): void;
        on(type: any, listener: any): any;
        once(type: any, listener: any): any;
        prependListener(type: any, listener: any): any;
        prependOnceListener(type: any, listener: any): any;
        remove(ns: any, ops: any, options: any, callback: any): any;
        removeAllListeners(type: any, ...args: any[]): any;
        removeListener(type: any, listener: any): any;
        selectServer(selector: any, options: any, callback: any): void;
        setMaxListeners(n: any): any;
        unref(): void;
        update(ns: any, ops: any, options: any, callback: any): any;
    }
    class Cursor {
        static CLOSED: number;
        static GET_MORE: number;
        static INIT: number;
        static OPEN: number;
        constructor(bson: any, ns: any, cmd: any, options: any, topology: any, topologyOptions: any, ...args: any[]);
        s: any;
        sortValue: any;
        addCursorFlag(flag: any, value: any): any;
        addListener(ev: any, fn: any): any;
        addQueryModifier(name: any, value: any): any;
        batchSize(value: any): any;
        bufferedCount(): any;
        clone(): any;
        close(options: any, callback: any): any;
        collation(value: any): any;
        comment(value: any): any;
        count(applySkipLimit: any, opts: any, callback: any): any;
        cursorBatchSize(): any;
        cursorLimit(): any;
        cursorSkip(): any;
        destroy(err: any): void;
        each(args: any): any;
        emit(type: any, ...args: any[]): any;
        eventNames(): any;
        explain(callback: any): any;
        filter(filter: any): any;
        forEach(iterator: any, callback: any): any;
        getLogger(): any;
        getMaxListeners(): any;
        hasNext(callback: any): any;
        hint(hint: any): any;
        isClosed(): any;
        isDead(): any;
        isKilled(): any;
        isNotified(): any;
        isPaused(): any;
        kill(callback: any): void;
        limit(value: any): any;
        listenerCount(type: any): any;
        listeners(type: any): any;
        map(transform: any): any;
        max(max: any): any;
        maxAwaitTimeMS(value: any): any;
        maxScan(args: any): any;
        maxTimeMS(value: any): any;
        maxTimeMs(value: any): any;
        min(min: any): any;
        next(callback: any): any;
        on(ev: any, fn: any): any;
        once(type: any, listener: any): any;
        pause(): any;
        pipe(dest: any, pipeOpts: any): any;
        prependListener(type: any, listener: any): any;
        prependOnceListener(type: any, listener: any): any;
        project(value: any): any;
        push(chunk: any, encoding: any): any;
        read(n: any): any;
        readBufferedDocuments(number: any): any;
        removeAllListeners(type: any, ...args: any[]): any;
        removeListener(type: any, listener: any): any;
        resume(): any;
        returnKey(value: any): any;
        rewind(): void;
        setCursorBatchSize(value: any): void;
        setCursorLimit(value: any): void;
        setCursorOption(field: any, value: any): any;
        setCursorSkip(value: any): void;
        setEncoding(enc: any): any;
        setMaxListeners(n: any): any;
        setReadPreference(readPreference: any): any;
        showRecordId(value: any): any;
        skip(value: any): any;
        snapshot(args: any): any;
        sort(keyOrList: any, direction: any): any;
        stream(options: any): any;
        toArray(callback: any): any;
        transformStream(options: any): any;
        unpipe(dest: any): any;
        unshift(chunk: any): any;
        wrap(stream: any): any;
    }
    class DBRef {
        // Circular reference from index.mongo.DBRef
        static DBRef: any;
        constructor(namespace: any, oid: any, db: any);
        namespace: any;
        oid: any;
        db: any;
        toJSON(): any;
    }
    class Db {
        static SYSTEM_COMMAND_COLLECTION: string;
        static SYSTEM_INDEX_COLLECTION: string;
        static SYSTEM_JS_COLLECTION: string;
        static SYSTEM_NAMESPACE_COLLECTION: string;
        static SYSTEM_PROFILE_COLLECTION: string;
        static SYSTEM_USER_COLLECTION: string;
        constructor(databaseName: any, topology: any, options: any);
        s: any;
        addChild(db: any): any;
        addListener(type: any, listener: any): any;
        addUser(username: any, password: any, options: any, callback: any): any;
        admin(): any;
        collection(name: any, options: any, callback: any): any;
        collections(options: any, callback: any): any;
        command(command: any, options: any, callback: any): any;
        createCollection(...args: any[]): any;
        createIndex(name: any, fieldOrSpec: any, options: any, callback: any): any;
        dropCollection(name: any, options: any, callback: any): any;
        dropDatabase(options: any, callback: any): any;
        emit(type: any, ...args: any[]): any;
        ensureIndex(args: any): any;
        eventNames(): any;
        executeDbAdminCommand(selector: any, options: any, callback: any): any;
        getLogger(): any;
        getMaxListeners(): any;
        indexInformation(name: any, options: any, callback: any): any;
        listCollections(filter: any, options: any): any;
        listenerCount(type: any): any;
        listeners(type: any): any;
        on(type: any, listener: any): any;
        once(type: any, listener: any): any;
        prependListener(type: any, listener: any): any;
        prependOnceListener(type: any, listener: any): any;
        profilingInfo(args: any): any;
        profilingLevel(options: any, callback: any): any;
        removeAllListeners(type: any, ...args: any[]): any;
        removeListener(type: any, listener: any): any;
        removeUser(username: any, options: any, callback: any): any;
        renameCollection(fromCollection: any, toCollection: any, options: any, callback: any): any;
        setMaxListeners(n: any): any;
        setProfilingLevel(level: any, options: any, callback: any): any;
        stats(options: any, callback: any): any;
        unref(): void;
        watch(pipeline: any, options: any): any;
    }
    class Decimal128 {
        // Circular reference from index.mongo.Decimal128
        static Decimal128: any;
        static fromString(string: any): any;
        constructor(bytes: any);
        bytes: any;
        toJSON(): any;
    }
    class Double {
        // Circular reference from index.mongo.Double
        static Double: any;
        constructor(value: any);
        value: any;
        toJSON(): any;
        valueOf(): any;
    }
    class GridFSBucket {
        constructor(db: any, options: any);
        s: any;
        addListener(type: any, listener: any): any;
        drop(callback: any): any;
        emit(type: any, ...args: any[]): any;
        eventNames(): any;
        find(filter: any, options: any): any;
        getLogger(): any;
        getMaxListeners(): any;
        listenerCount(type: any): any;
        listeners(type: any): any;
        on(type: any, listener: any): any;
        once(type: any, listener: any): any;
        openDownloadStream(id: any, options: any): any;
        openDownloadStreamByName(filename: any, options: any): any;
        openUploadStream(filename: any, options: any): any;
        openUploadStreamWithId(id: any, filename: any, options: any): any;
        prependListener(type: any, listener: any): any;
        prependOnceListener(type: any, listener: any): any;
        removeAllListeners(type: any, ...args: any[]): any;
        removeListener(type: any, listener: any): any;
        rename(id: any, filename: any, callback: any): any;
        setMaxListeners(n: any): any;
    }
    class GridStore {
        static DEFAULT_CONTENT_TYPE: string;
        static DEFAULT_ROOT_COLLECTION: string;
        static IO_SEEK_CUR: number;
        static IO_SEEK_END: number;
        static IO_SEEK_SET: number;
        static exist(db: any, fileIdObject: any, rootCollection: any, options: any, callback: any, ...args: any[]): any;
        static list(db: any, rootCollection: any, options: any, callback: any, ...args: any[]): any;
        static read(db: any, name: any, length: any, offset: any, options: any, callback: any, ...args: any[]): any;
        static readlines(db: any, name: any, separator: any, options: any, callback: any, ...args: any[]): any;
        static unlink(db: any, names: any, options: any, callback: any, ...args: any[]): any;
        constructor(db: any, id: any, filename: any, mode: any, options: any);
        db: any;
        referenceBy: any;
        fileId: any;
        filename: any;
        referenceBy: any;
        filename: any;
        fileId: any;
        referenceBy: any;
        fileId: any;
        filename: any;
        mode: any;
        options: any;
        isOpen: any;
        root: any;
        position: any;
        readPreference: any;
        writeConcern: any;
        internalChunkSize: any;
        promiseLibrary: any;
        chunkCollection(callback: any): any;
        close(options: any, callback: any): any;
        collection(callback: any): any;
        destroy(): void;
        eof(): any;
        getc(options: any, callback: any): any;
        open(options: any, callback: any): any;
        puts(string: any, options: any, callback: any): any;
        read(length: any, buffer: any, options: any, callback: any, ...args: any[]): any;
        readlines(separator: any, options: any, callback: any, ...args: any[]): any;
        rewind(options: any, callback: any): any;
        seek(position: any, seekLocation: any, options: any, callback: any, ...args: any[]): any;
        stream(): any;
        tell(callback: any): any;
        unlink(options: any, callback: any): any;
        write(data: any, close: any, options: any, callback: any): any;
        writeFile(file: any, options: any, callback: any): any;
    }
    class Int32 {
        // Circular reference from index.mongo.Int32
        static Int32: any;
        constructor(value: any);
        value: any;
        toJSON(): any;
        valueOf(): any;
    }
    class Logger {
        static currentLogger(): any;
        static filter(type: any, values: any): void;
        static reset(): void;
        static setCurrentLogger(logger: any): void;
        static setLevel(_level: any): void;
        constructor(className: any, options: any);
        className: any;
        debug(message: any, object: any): void;
        error(message: any, object: any): void;
        info(message: any, object: any): void;
        isDebug(): any;
        isError(): any;
        isInfo(): any;
        isWarn(): any;
        warn(message: any, object: any): void;
    }
    class Long {
        static INT_CACHE_: {
            -1: {
        add: any;
        and: any;
        compare: any;
        div: any;
        equals: any;
        getHighBits: any;
        getLowBits: any;
        getLowBitsUnsigned: any;
        getNumBitsAbs: any;
        greaterThan: any;
        greaterThanOrEqual: any;
        high_: any;
        isNegative: any;
        isOdd: any;
        isZero: any;
        lessThan: any;
        lessThanOrEqual: any;
        low_: any;
        modulo: any;
        multiply: any;
        negate: any;
        not: any;
        notEquals: any;
        or: any;
        shiftLeft: any;
        shiftRight: any;
        shiftRightUnsigned: any;
        subtract: any;
        toInt: any;
        toJSON: any;
        toNumber: any;
        toString: any;
        xor: any;
    };
    0: {
        add: any;
        and: any;
        compare: any;
        div: any;
        equals: any;
        getHighBits: any;
        getLowBits: any;
        getLowBitsUnsigned: any;
        getNumBitsAbs: any;
        greaterThan: any;
        greaterThanOrEqual: any;
        high_: any;
        isNegative: any;
        isOdd: any;
        isZero: any;
        lessThan: any;
        lessThanOrEqual: any;
        low_: any;
        modulo: any;
        multiply: any;
        negate: any;
        not: any;
        notEquals: any;
        or: any;
        shiftLeft: any;
        shiftRight: any;
        shiftRightUnsigned: any;
        subtract: any;
        toInt: any;
        toJSON: any;
        toNumber: any;
        toString: any;
        xor: any;
    };
    1: {
        add: any;
        and: any;
        compare: any;
        div: any;
        equals: any;
        getHighBits: any;
        getLowBits: any;
        getLowBitsUnsigned: any;
        getNumBitsAbs: any;
        greaterThan: any;
        greaterThanOrEqual: any;
        high_: any;
        isNegative: any;
        isOdd: any;
        isZero: any;
        lessThan: any;
        lessThanOrEqual: any;
        low_: any;
        modulo: any;
        multiply: any;
        negate: any;
        not: any;
        notEquals: any;
        or: any;
        shiftLeft: any;
        shiftRight: any;
        shiftRightUnsigned: any;
        subtract: any;
        toInt: any;
        toJSON: any;
        toNumber: any;
        toString: any;
        xor: any;
    };
};
        // Circular reference from index.mongo.Long
        static Long: any;
        static TWO_PWR_16_DBL_: number;
        static TWO_PWR_24_DBL_: number;
        static TWO_PWR_31_DBL_: number;
        static TWO_PWR_32_DBL_: number;
        static TWO_PWR_48_DBL_: number;
        static TWO_PWR_63_DBL_: number;
        static TWO_PWR_64_DBL_: number;
        static fromBits(lowBits: any, highBits: any): any;
        static fromInt(value: any): any;
        static fromNumber(value: any): any;
        static fromString(str: any, opt_radix: any): any;
constructor(low: any, high: any);
low_: any;
high_: any;
add(other: any): any;
and(other: any): any;
compare(other: any): any;
div(other: any): any;
equals(other: any): any;
getHighBits(): any;
getLowBits(): any;
getLowBitsUnsigned(): any;
getNumBitsAbs(): any;
greaterThan(other: any): any;
greaterThanOrEqual(other: any): any;
isNegative(): any;
isOdd(): any;
isZero(): any;
lessThan(other: any): any;
lessThanOrEqual(other: any): any;
modulo(other: any): any;
multiply(other: any): any;
negate(): any;
not(): any;
notEquals(other: any): any;
or(other: any): any;
shiftLeft(numBits: any): any;
shiftRight(numBits: any): any;
shiftRightUnsigned(numBits: any): any;
subtract(other: any): any;
toInt(): any;
toJSON(): any;
toNumber(): any;
toString(opt_radix: any): any;
xor(other: any): any;
    }
namespace Long {
    namespace MAX_VALUE {
        function add(other: any): any;
        function and(other: any): any;
        function compare(other: any): any;
        function div(other: any): any;
        function equals(other: any): any;
        function getHighBits(): any;
        function getLowBits(): any;
        function getLowBitsUnsigned(): any;
        function getNumBitsAbs(): any;
        function greaterThan(other: any): any;
        function greaterThanOrEqual(other: any): any;
        const high_: number;
        function isNegative(): any;
        function isOdd(): any;
        function isZero(): any;
        function lessThan(other: any): any;
        function lessThanOrEqual(other: any): any;
        const low_: number;
        function modulo(other: any): any;
        function multiply(other: any): any;
        function negate(): any;
        function not(): any;
        function notEquals(other: any): any;
        function or(other: any): any;
        function shiftLeft(numBits: any): any;
        function shiftRight(numBits: any): any;
        function shiftRightUnsigned(numBits: any): any;
        function subtract(other: any): any;
        function toInt(): any;
        function toJSON(): any;
        function toNumber(): any;
        function toString(opt_radix: any): any;
        function xor(other: any): any;
    }
    namespace MIN_VALUE {
        function add(other: any): any;
        function and(other: any): any;
        function compare(other: any): any;
        function div(other: any): any;
        function equals(other: any): any;
        function getHighBits(): any;
        function getLowBits(): any;
        function getLowBitsUnsigned(): any;
        function getNumBitsAbs(): any;
        function greaterThan(other: any): any;
        function greaterThanOrEqual(other: any): any;
        const high_: number;
        function isNegative(): any;
        function isOdd(): any;
        function isZero(): any;
        function lessThan(other: any): any;
        function lessThanOrEqual(other: any): any;
        const low_: number;
        function modulo(other: any): any;
        function multiply(other: any): any;
        function negate(): any;
        function not(): any;
        function notEquals(other: any): any;
        function or(other: any): any;
        function shiftLeft(numBits: any): any;
        function shiftRight(numBits: any): any;
        function shiftRightUnsigned(numBits: any): any;
        function subtract(other: any): any;
        function toInt(): any;
        function toJSON(): any;
        function toNumber(): any;
        function toString(opt_radix: any): any;
        function xor(other: any): any;
    }
    namespace NEG_ONE {
        function add(other: any): any;
        function and(other: any): any;
        function compare(other: any): any;
        function div(other: any): any;
        function equals(other: any): any;
        function getHighBits(): any;
        function getLowBits(): any;
        function getLowBitsUnsigned(): any;
        function getNumBitsAbs(): any;
        function greaterThan(other: any): any;
        function greaterThanOrEqual(other: any): any;
        const high_: number;
        function isNegative(): any;
        function isOdd(): any;
        function isZero(): any;
        function lessThan(other: any): any;
        function lessThanOrEqual(other: any): any;
        const low_: number;
        function modulo(other: any): any;
        function multiply(other: any): any;
        function negate(): any;
        function not(): any;
        function notEquals(other: any): any;
        function or(other: any): any;
        function shiftLeft(numBits: any): any;
        function shiftRight(numBits: any): any;
        function shiftRightUnsigned(numBits: any): any;
        function subtract(other: any): any;
        function toInt(): any;
        function toJSON(): any;
        function toNumber(): any;
        function toString(opt_radix: any): any;
        function xor(other: any): any;
    }
    namespace ONE {
        function add(other: any): any;
        function and(other: any): any;
        function compare(other: any): any;
        function div(other: any): any;
        function equals(other: any): any;
        function getHighBits(): any;
        function getLowBits(): any;
        function getLowBitsUnsigned(): any;
        function getNumBitsAbs(): any;
        function greaterThan(other: any): any;
        function greaterThanOrEqual(other: any): any;
        const high_: number;
        function isNegative(): any;
        function isOdd(): any;
        function isZero(): any;
        function lessThan(other: any): any;
        function lessThanOrEqual(other: any): any;
        const low_: number;
        function modulo(other: any): any;
        function multiply(other: any): any;
        function negate(): any;
        function not(): any;
        function notEquals(other: any): any;
        function or(other: any): any;
        function shiftLeft(numBits: any): any;
        function shiftRight(numBits: any): any;
        function shiftRightUnsigned(numBits: any): any;
        function subtract(other: any): any;
        function toInt(): any;
        function toJSON(): any;
        function toNumber(): any;
        function toString(opt_radix: any): any;
        function xor(other: any): any;
    }
    namespace TWO_PWR_24_ {
        function add(other: any): any;
        function and(other: any): any;
        function compare(other: any): any;
        function div(other: any): any;
        function equals(other: any): any;
        function getHighBits(): any;
        function getLowBits(): any;
        function getLowBitsUnsigned(): any;
        function getNumBitsAbs(): any;
        function greaterThan(other: any): any;
        function greaterThanOrEqual(other: any): any;
        const high_: number;
        function isNegative(): any;
        function isOdd(): any;
        function isZero(): any;
        function lessThan(other: any): any;
        function lessThanOrEqual(other: any): any;
        const low_: number;
        function modulo(other: any): any;
        function multiply(other: any): any;
        function negate(): any;
        function not(): any;
        function notEquals(other: any): any;
        function or(other: any): any;
        function shiftLeft(numBits: any): any;
        function shiftRight(numBits: any): any;
        function shiftRightUnsigned(numBits: any): any;
        function subtract(other: any): any;
        function toInt(): any;
        function toJSON(): any;
        function toNumber(): any;
        function toString(opt_radix: any): any;
        function xor(other: any): any;
    }
    namespace ZERO {
        function add(other: any): any;
        function and(other: any): any;
        function compare(other: any): any;
        function div(other: any): any;
        function equals(other: any): any;
        function getHighBits(): any;
        function getLowBits(): any;
        function getLowBitsUnsigned(): any;
        function getNumBitsAbs(): any;
        function greaterThan(other: any): any;
        function greaterThanOrEqual(other: any): any;
        const high_: number;
        function isNegative(): any;
        function isOdd(): any;
        function isZero(): any;
        function lessThan(other: any): any;
        function lessThanOrEqual(other: any): any;
        const low_: number;
        function modulo(other: any): any;
        function multiply(other: any): any;
        function negate(): any;
        function not(): any;
        function notEquals(other: any): any;
        function or(other: any): any;
        function shiftLeft(numBits: any): any;
        function shiftRight(numBits: any): any;
        function shiftRightUnsigned(numBits: any): any;
        function subtract(other: any): any;
        function toInt(): any;
        function toJSON(): any;
        function toNumber(): any;
        function toString(opt_radix: any): any;
        function xor(other: any): any;
    }
}
class Map {
    // Circular reference from index.mongo.Map
    static Map: any;
    clear(): any;
    entries(): any;
    forEach(p0: any): any;
    get(p0: any): any;
    has(p0: any): any;
    keys(): any;
    set(p0: any, p1: any): any;
    values(): any;
}
function MaxKey(): any;
namespace MaxKey {
    // Circular reference from index.mongo.MaxKey
    const MaxKey: any;
}
function MinKey(): any;
namespace MinKey {
    // Circular reference from index.mongo.MinKey
    const MinKey: any;
}
class MongoClient {
    // Circular reference from index.mongo.MongoClient
    static connect: any;
    constructor(url: any, options: any);
    s: any;
    addListener(type: any, listener: any): any;
    close(force: any, callback: any): any;
    connect(callback: any): any;
    db(dbName: any, options: any): any;
    emit(type: any, ...args: any[]): any;
    eventNames(): any;
    getLogger(): any;
    getMaxListeners(): any;
    isConnected(options: any): any;
    listenerCount(type: any): any;
    listeners(type: any): any;
    logout(options: any, callback: any): any;
    on(type: any, listener: any): any;
    once(type: any, listener: any): any;
    prependListener(type: any, listener: any): any;
    prependOnceListener(type: any, listener: any): any;
    removeAllListeners(type: any, ...args: any[]): any;
    removeListener(type: any, listener: any): any;
    setMaxListeners(n: any): any;
    startSession(options: any): any;
    watch(pipeline: any, options: any): any;
    withSession(options: any, operation: any): any;
}
class MongoError {
    static captureStackTrace(p0: any, p1: any): any;
    static create(options: any): any;
    static stackTraceLimit: number;
    constructor(message: any);
    stack: any;
    name: any;
}
class MongoNetworkError {
    static captureStackTrace(p0: any, p1: any): any;
    static create(options: any): any;
    static stackTraceLimit: number;
    constructor(message: any);
    name: any;
    errorLabels: any;
}
class Mongos {
    static defaultMaxListeners: any;
    static init(): void;
    static listenerCount(emitter: any, type: any): any;
    static usingDomains: boolean;
    constructor(servers: any, options: any);
    s: any;
    addListener(type: any, listener: any): any;
    auth(...args: any[]): void;
    capabilities(): any;
    close(forceClosed: any): void;
    command(ns: any, cmd: any, options: any, callback: any): void;
    connect(_options: any, callback: any): void;
    connections(): any;
    cursor(ns: any, cmd: any, options: any): any;
    emit(type: any, ...args: any[]): any;
    endSessions(sessions: any, callback: any): any;
    eventNames(): any;
    getMaxListeners(): any;
    hasSessionSupport(): any;
    insert(ns: any, ops: any, options: any, callback: any): void;
    isConnected(options: any): any;
    isDestroyed(): any;
    lastIsMaster(): any;
    listenerCount(type: any): any;
    listeners(type: any): any;
    logout(...args: any[]): void;
    on(type: any, listener: any): any;
    once(type: any, listener: any): any;
    prependListener(type: any, listener: any): any;
    prependOnceListener(type: any, listener: any): any;
    remove(ns: any, ops: any, options: any, callback: any): void;
    removeAllListeners(type: any, ...args: any[]): any;
    removeListener(type: any, listener: any): any;
    selectServer(selector: any, options: any, callback: any): any;
    setMaxListeners(n: any): any;
    startSession(options: any, clientOptions: any): any;
    unref(): any;
    update(ns: any, ops: any, options: any, callback: any): void;
}
namespace Mongos {
    class EventEmitter {
        // Circular reference from index.mongo.Mongos.EventEmitter
        static EventEmitter: any;
        static defaultMaxListeners: any;
        static init(): void;
        static listenerCount(emitter: any, type: any): any;
        static usingDomains: boolean;
        addListener(type: any, listener: any): any;
        emit(type: any, ...args: any[]): any;
        eventNames(): any;
        getMaxListeners(): any;
        listenerCount(type: any): any;
        listeners(type: any): any;
        on(type: any, listener: any): any;
        once(type: any, listener: any): any;
        prependListener(type: any, listener: any): any;
        prependOnceListener(type: any, listener: any): any;
        removeAllListeners(type: any, ...args: any[]): any;
        removeListener(type: any, listener: any): any;
        setMaxListeners(n: any): any;
    }
}
class ObjectID {
    // Circular reference from index.mongo.ObjectID
    static ObjectID: any;
    // Circular reference from index.mongo.ObjectID
    static ObjectId: any;
    static createFromHexString(string: any): any;
    static createFromTime(time: any): any;
    static createPk(): any;
    static index: number;
    static isValid(id: any): any;
    constructor(id: any);
    id: any;
    id: any;
    equals(otherId: any): any;
    generate(time: any): any;
    getInc(): any;
    getTimestamp(): any;
    get_inc(): any;
    toHexString(): any;
    toJSON(): any;
    toString(format: any): any;
}
class ObjectId {
    // Circular reference from index.mongo.ObjectId
    static ObjectID: any;
    // Circular reference from index.mongo.ObjectId
    static ObjectId: any;
    static createFromHexString(string: any): any;
    static createFromTime(time: any): any;
    static createPk(): any;
    static index: number;
    static isValid(id: any): any;
    constructor(id: any);
    id: any;
    id: any;
    equals(otherId: any): any;
    generate(time: any): any;
    getInc(): any;
    getTimestamp(): any;
    get_inc(): any;
    toHexString(): any;
    toJSON(): any;
    toString(format: any): any;
}
class ReadPreference {
    static NEAREST: string;
    static PRIMARY: string;
    static PRIMARY_PREFERRED: string;
    static SECONDARY: string;
    static SECONDARY_PREFERRED: string;
    static isValid(mode: any): any;
    constructor(mode: any, tags: any, options: any);
    mode: any;
    tags: any;
    maxStalenessSeconds: any;
    minWireVersion: any;
    equals(readPreference: any): any;
    isValid(mode: any): any;
    slaveOk(): any;
    toJSON(): any;
}
namespace ReadPreference {
    namespace nearest {
        function equals(readPreference: any): any;
        function isValid(mode: any): any;
        const mode: string;
        const preference: any;
        function slaveOk(): any;
        const tags: any;
        function toJSON(): any;
    }
    namespace primary {
        function equals(readPreference: any): any;
        function isValid(mode: any): any;
        const mode: string;
        const preference: any;
        function slaveOk(): any;
        const tags: any;
        function toJSON(): any;
    }
    namespace primaryPreferred {
        function equals(readPreference: any): any;
        function isValid(mode: any): any;
        const mode: string;
        const preference: any;
        function slaveOk(): any;
        const tags: any;
        function toJSON(): any;
    }
    namespace secondary {
        function equals(readPreference: any): any;
        function isValid(mode: any): any;
        const mode: string;
        const preference: any;
        function slaveOk(): any;
        const tags: any;
        function toJSON(): any;
    }
    namespace secondaryPreferred {
        function equals(readPreference: any): any;
        function isValid(mode: any): any;
        const mode: string;
        const preference: any;
        function slaveOk(): any;
        const tags: any;
        function toJSON(): any;
    }
}
class ReplSet {
    static defaultMaxListeners: any;
    static init(): void;
    static listenerCount(emitter: any, type: any): any;
    static usingDomains: boolean;
    constructor(servers: any, options: any);
    s: any;
    addListener(type: any, listener: any): any;
    auth(...args: any[]): void;
    capabilities(): any;
    close(forceClosed: any): void;
    command(ns: any, cmd: any, options: any, callback: any): void;
    connect(_options: any, callback: any): void;
    connections(): any;
    cursor(ns: any, cmd: any, options: any): any;
    emit(type: any, ...args: any[]): any;
    endSessions(sessions: any, callback: any): any;
    eventNames(): any;
    getMaxListeners(): any;
    hasSessionSupport(): any;
    insert(ns: any, ops: any, options: any, callback: any): void;
    isConnected(options: any): any;
    isDestroyed(): any;
    lastIsMaster(): any;
    listenerCount(type: any): any;
    listeners(type: any): any;
    logout(...args: any[]): void;
    on(type: any, listener: any): any;
    once(type: any, listener: any): any;
    prependListener(type: any, listener: any): any;
    prependOnceListener(type: any, listener: any): any;
    remove(ns: any, ops: any, options: any, callback: any): void;
    removeAllListeners(type: any, ...args: any[]): any;
    removeListener(type: any, listener: any): any;
    selectServer(selector: any, options: any, callback: any): any;
    setMaxListeners(n: any): any;
    startSession(options: any, clientOptions: any): any;
    unref(): any;
    update(ns: any, ops: any, options: any, callback: any): void;
}
namespace ReplSet {
    class EventEmitter {
        // Circular reference from index.mongo.ReplSet.EventEmitter
        static EventEmitter: any;
        static defaultMaxListeners: any;
        static init(): void;
        static listenerCount(emitter: any, type: any): any;
        static usingDomains: boolean;
        addListener(type: any, listener: any): any;
        emit(type: any, ...args: any[]): any;
        eventNames(): any;
        getMaxListeners(): any;
        listenerCount(type: any): any;
        listeners(type: any): any;
        on(type: any, listener: any): any;
        once(type: any, listener: any): any;
        prependListener(type: any, listener: any): any;
        prependOnceListener(type: any, listener: any): any;
        removeAllListeners(type: any, ...args: any[]): any;
        removeListener(type: any, listener: any): any;
        setMaxListeners(n: any): any;
    }
}
class Server {
    static defaultMaxListeners: any;
    static init(): void;
    static listenerCount(emitter: any, type: any): any;
    static usingDomains: boolean;
    constructor(host: any, port: any, options: any);
    s: any;
    addListener(type: any, listener: any): any;
    auth(...args: any[]): void;
    capabilities(): any;
    close(forceClosed: any): void;
    command(ns: any, cmd: any, options: any, callback: any): void;
    connect(_options: any, callback: any): void;
    connections(): any;
    cursor(ns: any, cmd: any, options: any): any;
    emit(type: any, ...args: any[]): any;
    endSessions(sessions: any, callback: any): any;
    eventNames(): any;
    getMaxListeners(): any;
    hasSessionSupport(): any;
    insert(ns: any, ops: any, options: any, callback: any): void;
    isConnected(options: any): any;
    isDestroyed(): any;
    lastIsMaster(): any;
    listenerCount(type: any): any;
    listeners(type: any): any;
    logout(...args: any[]): void;
    on(type: any, listener: any): any;
    once(type: any, listener: any): any;
    prependListener(type: any, listener: any): any;
    prependOnceListener(type: any, listener: any): any;
    remove(ns: any, ops: any, options: any, callback: any): void;
    removeAllListeners(type: any, ...args: any[]): any;
    removeListener(type: any, listener: any): any;
    selectServer(selector: any, options: any, callback: any): any;
    setMaxListeners(n: any): any;
    startSession(options: any, clientOptions: any): any;
    unref(): any;
    update(ns: any, ops: any, options: any, callback: any): void;
}
namespace Server {
    class EventEmitter {
        // Circular reference from index.mongo.Server.EventEmitter
        static EventEmitter: any;
        static defaultMaxListeners: any;
        static init(): void;
        static listenerCount(emitter: any, type: any): any;
        static usingDomains: boolean;
        addListener(type: any, listener: any): any;
        emit(type: any, ...args: any[]): any;
        eventNames(): any;
        getMaxListeners(): any;
        listenerCount(type: any): any;
        listeners(type: any): any;
        on(type: any, listener: any): any;
        once(type: any, listener: any): any;
        prependListener(type: any, listener: any): any;
        prependOnceListener(type: any, listener: any): any;
        removeAllListeners(type: any, ...args: any[]): any;
        removeListener(type: any, listener: any): any;
        setMaxListeners(n: any): any;
    }
}
class Symbol {
    // Circular reference from index.mongo.Symbol
    static Symbol: any;
    constructor(value: any);
    value: any;
    toJSON(): any;
    valueOf(): any;
}
class Timestamp {
    static INT_CACHE_: {
            -1: {
    add: any;
    and: any;
    compare: any;
    div: any;
    equals: any;
    getHighBits: any;
    getLowBits: any;
    getLowBitsUnsigned: any;
    getNumBitsAbs: any;
    greaterThan: any;
    greaterThanOrEqual: any;
    high_: any;
    isNegative: any;
    isOdd: any;
    isZero: any;
    lessThan: any;
    lessThanOrEqual: any;
    low_: any;
    modulo: any;
    multiply: any;
    negate: any;
    not: any;
    notEquals: any;
    or: any;
    shiftLeft: any;
    shiftRight: any;
    shiftRightUnsigned: any;
    subtract: any;
    toInt: any;
    toJSON: any;
    toNumber: any;
    toString: any;
    xor: any;
};
0: {
    add: any;
    and: any;
    compare: any;
    div: any;
    equals: any;
    getHighBits: any;
    getLowBits: any;
    getLowBitsUnsigned: any;
    getNumBitsAbs: any;
    greaterThan: any;
    greaterThanOrEqual: any;
    high_: any;
    isNegative: any;
    isOdd: any;
    isZero: any;
    lessThan: any;
    lessThanOrEqual: any;
    low_: any;
    modulo: any;
    multiply: any;
    negate: any;
    not: any;
    notEquals: any;
    or: any;
    shiftLeft: any;
    shiftRight: any;
    shiftRightUnsigned: any;
    subtract: any;
    toInt: any;
    toJSON: any;
    toNumber: any;
    toString: any;
    xor: any;
};
1: {
    add: any;
    and: any;
    compare: any;
    div: any;
    equals: any;
    getHighBits: any;
    getLowBits: any;
    getLowBitsUnsigned: any;
    getNumBitsAbs: any;
    greaterThan: any;
    greaterThanOrEqual: any;
    high_: any;
    isNegative: any;
    isOdd: any;
    isZero: any;
    lessThan: any;
    lessThanOrEqual: any;
    low_: any;
    modulo: any;
    multiply: any;
    negate: any;
    not: any;
    notEquals: any;
    or: any;
    shiftLeft: any;
    shiftRight: any;
    shiftRightUnsigned: any;
    subtract: any;
    toInt: any;
    toJSON: any;
    toNumber: any;
    toString: any;
    xor: any;
};
        };
        static TWO_PWR_16_DBL_: number;
        static TWO_PWR_24_DBL_: number;
        static TWO_PWR_31_DBL_: number;
        static TWO_PWR_32_DBL_: number;
        static TWO_PWR_48_DBL_: number;
        static TWO_PWR_63_DBL_: number;
        static TWO_PWR_64_DBL_: number;
        // Circular reference from index.mongo.Timestamp
        static Timestamp: any;
        static fromBits(lowBits: any, highBits: any): any;
        static fromInt(value: any): any;
        static fromNumber(value: any): any;
        static fromString(str: any, opt_radix: any): any;
constructor(low: any, high: any);
low_: any;
high_: any;
add(other: any): any;
and(other: any): any;
compare(other: any): any;
div(other: any): any;
equals(other: any): any;
getHighBits(): any;
getLowBits(): any;
getLowBitsUnsigned(): any;
getNumBitsAbs(): any;
greaterThan(other: any): any;
greaterThanOrEqual(other: any): any;
isNegative(): any;
isOdd(): any;
isZero(): any;
lessThan(other: any): any;
lessThanOrEqual(other: any): any;
modulo(other: any): any;
multiply(other: any): any;
negate(): any;
not(): any;
notEquals(other: any): any;
or(other: any): any;
shiftLeft(numBits: any): any;
shiftRight(numBits: any): any;
shiftRightUnsigned(numBits: any): any;
subtract(other: any): any;
toInt(): any;
toJSON(): any;
toNumber(): any;
toString(opt_radix: any): any;
xor(other: any): any;
    }
namespace Timestamp {
    namespace MAX_VALUE {
        function add(other: any): any;
        function and(other: any): any;
        function compare(other: any): any;
        function div(other: any): any;
        function equals(other: any): any;
        function getHighBits(): any;
        function getLowBits(): any;
        function getLowBitsUnsigned(): any;
        function getNumBitsAbs(): any;
        function greaterThan(other: any): any;
        function greaterThanOrEqual(other: any): any;
        const high_: number;
        function isNegative(): any;
        function isOdd(): any;
        function isZero(): any;
        function lessThan(other: any): any;
        function lessThanOrEqual(other: any): any;
        const low_: number;
        function modulo(other: any): any;
        function multiply(other: any): any;
        function negate(): any;
        function not(): any;
        function notEquals(other: any): any;
        function or(other: any): any;
        function shiftLeft(numBits: any): any;
        function shiftRight(numBits: any): any;
        function shiftRightUnsigned(numBits: any): any;
        function subtract(other: any): any;
        function toInt(): any;
        function toJSON(): any;
        function toNumber(): any;
        function toString(opt_radix: any): any;
        function xor(other: any): any;
    }
    namespace MIN_VALUE {
        function add(other: any): any;
        function and(other: any): any;
        function compare(other: any): any;
        function div(other: any): any;
        function equals(other: any): any;
        function getHighBits(): any;
        function getLowBits(): any;
        function getLowBitsUnsigned(): any;
        function getNumBitsAbs(): any;
        function greaterThan(other: any): any;
        function greaterThanOrEqual(other: any): any;
        const high_: number;
        function isNegative(): any;
        function isOdd(): any;
        function isZero(): any;
        function lessThan(other: any): any;
        function lessThanOrEqual(other: any): any;
        const low_: number;
        function modulo(other: any): any;
        function multiply(other: any): any;
        function negate(): any;
        function not(): any;
        function notEquals(other: any): any;
        function or(other: any): any;
        function shiftLeft(numBits: any): any;
        function shiftRight(numBits: any): any;
        function shiftRightUnsigned(numBits: any): any;
        function subtract(other: any): any;
        function toInt(): any;
        function toJSON(): any;
        function toNumber(): any;
        function toString(opt_radix: any): any;
        function xor(other: any): any;
    }
    namespace NEG_ONE {
        function add(other: any): any;
        function and(other: any): any;
        function compare(other: any): any;
        function div(other: any): any;
        function equals(other: any): any;
        function getHighBits(): any;
        function getLowBits(): any;
        function getLowBitsUnsigned(): any;
        function getNumBitsAbs(): any;
        function greaterThan(other: any): any;
        function greaterThanOrEqual(other: any): any;
        const high_: number;
        function isNegative(): any;
        function isOdd(): any;
        function isZero(): any;
        function lessThan(other: any): any;
        function lessThanOrEqual(other: any): any;
        const low_: number;
        function modulo(other: any): any;
        function multiply(other: any): any;
        function negate(): any;
        function not(): any;
        function notEquals(other: any): any;
        function or(other: any): any;
        function shiftLeft(numBits: any): any;
        function shiftRight(numBits: any): any;
        function shiftRightUnsigned(numBits: any): any;
        function subtract(other: any): any;
        function toInt(): any;
        function toJSON(): any;
        function toNumber(): any;
        function toString(opt_radix: any): any;
        function xor(other: any): any;
    }
    namespace ONE {
        function add(other: any): any;
        function and(other: any): any;
        function compare(other: any): any;
        function div(other: any): any;
        function equals(other: any): any;
        function getHighBits(): any;
        function getLowBits(): any;
        function getLowBitsUnsigned(): any;
        function getNumBitsAbs(): any;
        function greaterThan(other: any): any;
        function greaterThanOrEqual(other: any): any;
        const high_: number;
        function isNegative(): any;
        function isOdd(): any;
        function isZero(): any;
        function lessThan(other: any): any;
        function lessThanOrEqual(other: any): any;
        const low_: number;
        function modulo(other: any): any;
        function multiply(other: any): any;
        function negate(): any;
        function not(): any;
        function notEquals(other: any): any;
        function or(other: any): any;
        function shiftLeft(numBits: any): any;
        function shiftRight(numBits: any): any;
        function shiftRightUnsigned(numBits: any): any;
        function subtract(other: any): any;
        function toInt(): any;
        function toJSON(): any;
        function toNumber(): any;
        function toString(opt_radix: any): any;
        function xor(other: any): any;
    }
    namespace TWO_PWR_24_ {
        function add(other: any): any;
        function and(other: any): any;
        function compare(other: any): any;
        function div(other: any): any;
        function equals(other: any): any;
        function getHighBits(): any;
        function getLowBits(): any;
        function getLowBitsUnsigned(): any;
        function getNumBitsAbs(): any;
        function greaterThan(other: any): any;
        function greaterThanOrEqual(other: any): any;
        const high_: number;
        function isNegative(): any;
        function isOdd(): any;
        function isZero(): any;
        function lessThan(other: any): any;
        function lessThanOrEqual(other: any): any;
        const low_: number;
        function modulo(other: any): any;
        function multiply(other: any): any;
        function negate(): any;
        function not(): any;
        function notEquals(other: any): any;
        function or(other: any): any;
        function shiftLeft(numBits: any): any;
        function shiftRight(numBits: any): any;
        function shiftRightUnsigned(numBits: any): any;
        function subtract(other: any): any;
        function toInt(): any;
        function toJSON(): any;
        function toNumber(): any;
        function toString(opt_radix: any): any;
        function xor(other: any): any;
    }
    namespace ZERO {
        function add(other: any): any;
        function and(other: any): any;
        function compare(other: any): any;
        function div(other: any): any;
        function equals(other: any): any;
        function getHighBits(): any;
        function getLowBits(): any;
        function getLowBitsUnsigned(): any;
        function getNumBitsAbs(): any;
        function greaterThan(other: any): any;
        function greaterThanOrEqual(other: any): any;
        const high_: number;
        function isNegative(): any;
        function isOdd(): any;
        function isZero(): any;
        function lessThan(other: any): any;
        function lessThanOrEqual(other: any): any;
        const low_: number;
        function modulo(other: any): any;
        function multiply(other: any): any;
        function negate(): any;
        function not(): any;
        function notEquals(other: any): any;
        function or(other: any): any;
        function shiftLeft(numBits: any): any;
        function shiftRight(numBits: any): any;
        function shiftRightUnsigned(numBits: any): any;
        function subtract(other: any): any;
        function toInt(): any;
        function toJSON(): any;
        function toNumber(): any;
        function toString(opt_radix: any): any;
        function xor(other: any): any;
    }
}
// Circular reference from index.mongo
const connect: any;
function instrument(options: any, callback: any): any;
}
export class mquery {
    static Collection(col: any): void;
    static canMerge(conds: any): any;
    static env: {
        isBrowser: boolean;
        isMongo: boolean;
        isNode: string[];
        type: string;
    };
    static setGlobalTraceFunction(traceFunction: any): void;
    static use$geoWithin: any;
    constructor(criteria: any, options: any);
    op: any;
    options: any;
    $where(js: any): any;
    all(...args: any[]): any;
    and(array: any): any;
    batchSize(v: any): any;
    box(...args: any[]): any;
    circle(...args: any[]): any;
    collation(value: any): any;
    collection(coll: any): any;
    comment(v: any): any;
    count(criteria: any, callback: any): any;
    cursor(criteria: any): any;
    deleteMany(criteria: any, callback: any): any;
    deleteOne(criteria: any, callback: any): any;
    distinct(criteria: any, field: any, callback: any): any;
    elemMatch(...args: any[]): any;
    eq(val: any): any;
    equals(val: any): any;
    exec(op: any, callback: any): any;
    exists(...args: any[]): any;
    find(criteria: any, callback: any): any;
    findOne(criteria: any, callback: any): any;
    findOneAndDelete(conditions: any, options: any, callback: any): any;
    findOneAndRemove(conditions: any, options: any, callback: any): any;
    findOneAndUpdate(criteria: any, doc: any, options: any, callback: any, ...args: any[]): any;
    geometry(...args: any[]): any;
    gt(...args: any[]): any;
    gte(...args: any[]): any;
    hint(...args: any[]): any;
    intersects(...args: any[]): any;
    j(val: any): any;
    limit(v: any): any;
    lt(...args: any[]): any;
    lte(...args: any[]): any;
    maxDistance(...args: any[]): any;
    maxScan(v: any): any;
    maxTime(ms: any): any;
    maxTimeMS(ms: any): any;
    merge(source: any): any;
    minDistance(...args: any[]): any;
    mod(...args: any[]): any;
    ne(...args: any[]): any;
    near(...args: any[]): any;
    nin(...args: any[]): any;
    nor(array: any): any;
    or(array: any): any;
    polygon(...args: any[]): any;
    r(level: any): any;
    read(pref: any, ...args: any[]): any;
    readConcern(level: any): any;
    regex(...args: any[]): any;
    remove(criteria: any, callback: any): any;
    replaceOne(criteria: any, doc: any, options: any, callback: any, ...args: any[]): any;
    select(...args: any[]): any;
    selected(): any;
    selectedExclusively(): any;
    selectedInclusively(): any;
    setOptions(options: any): any;
    setReadPreference(pref: any, ...args: any[]): any;
    setTraceFunction(traceFunction: any): any;
    size(...args: any[]): any;
    skip(v: any): any;
    slaveOk(v: any, ...args: any[]): any;
    slice(...args: any[]): any;
    snapshot(...args: any[]): any;
    sort(arg: any, ...args: any[]): any;
    stream(streamOptions: any): any;
    tailable(...args: any[]): any;
    then(resolve: any, reject: any): any;
    thunk(): any;
    toConstructor(): any;
    update(criteria: any, doc: any, options: any, callback: any, ...args: any[]): any;
    updateMany(criteria: any, doc: any, options: any, callback: any, ...args: any[]): any;
    updateOne(criteria: any, doc: any, options: any, callback: any, ...args: any[]): any;
    w(concern: any): any;
    wTimeout(ms: any): any;
    where(...args: any[]): any;
    within(...args: any[]): any;
    writeConcern(concern: any): any;
    wtimeout(ms: any): any;
}
export namespace mquery {
    class BaseCollection {
        static methods: string[];
        aggregate(): void;
        count(): void;
        deleteMany(): void;
        deleteOne(): void;
        distinct(): void;
        find(): void;
        findAndModify(): void;
        findOne(): void;
        findStream(): void;
        remove(): void;
        replaceOne(): void;
        update(): void;
        updateMany(): void;
        updateOne(): void;
    }
    class Promise {
        static all(p0: any): any;
        static race(p0: any): any;
        static reject(p0: any): any;
        static resolve(p0: any): any;
        constructor(p0: any);
        then(p0: any, p1: any): any;
    }
    namespace permissions {
        function count(self: any): any;
        namespace count {
            const batchSize: boolean;
            const comment: boolean;
            const maxScan: boolean;
            const slice: boolean;
            const snapshot: boolean;
            const tailable: boolean;
        }
        function distinct(self: any): any;
        namespace distinct {
            const batchSize: boolean;
            const comment: boolean;
            const hint: boolean;
            const limit: boolean;
            const maxScan: boolean;
            const select: boolean;
            const skip: boolean;
            const slice: boolean;
            const snapshot: boolean;
            const sort: boolean;
            const tailable: boolean;
        }
        function findOneAndRemove(self: any): any;
        namespace findOneAndRemove {
            const batchSize: boolean;
            const comment: boolean;
            const hint: boolean;
            const limit: boolean;
            const maxScan: boolean;
            const skip: boolean;
            const snapshot: boolean;
            const tailable: boolean;
        }
        function findOneAndUpdate(self: any): any;
        namespace findOneAndUpdate {
            const batchSize: boolean;
            const comment: boolean;
            const hint: boolean;
            const limit: boolean;
            const maxScan: boolean;
            const skip: boolean;
            const snapshot: boolean;
            const tailable: boolean;
        }
    }
    namespace utils {
        function clone(obj: any, options: any): any;
        function cloneArray(arr: any, options: any): any;
        function cloneBuffer(buff: any): any;
        function cloneObject(obj: any, options: any): any;
        function create(p0: any, p1: any): any;
        function inherits(ctor: any, superCtor: any): void;
        function isArgumentsObject(v: any): any;
        function isArray(arg: any): any;
        function isObject(arg: any): any;
        function keys(p0: any): any;
        function merge(to: any, from: any): void;
        function mergeClone(to: any, from: any): void;
        function readConcern(concern: any): any;
        function readPref(pref: any): any;
        function soon(callback: any, arg1: any, arg2: any, arg3: any, ...args: any[]): any;
        function tick(callback: any): any;
        function toString(arg: any): any;
    }
}
export function now(): any;
export const options: {
    pluralization: boolean;
};
export function plugin(fn: any, opts: any): any;
export const plugins: Function[][];
export function pluralize(fn: any, ...args: any[]): any;
export function set(key: any, value: any, ...args: any[]): any;
export function startSession(...args: any[]): any;
export const version: string;